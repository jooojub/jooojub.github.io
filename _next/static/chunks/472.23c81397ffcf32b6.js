"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[472],{3472:function(n){n.exports=JSON.parse('{"content":"\\n\\n#### Requires\\n: compiler: gcc 2.8 later\\n***\\n\\nIf I use `char` without the compile option, is it `signed` or `unsigned`?\\nResults will vary by `architecture` and `compiler`.\\n\\nMany people mostly write code thinking that `char` is `signed char`.\\nBut this is dangerous code because it depends on architecture or compiler option.\\nThis is a coding practice you should absolutely avoid, especially if you need to write architecture independent code.\\n\\nThe gcc compiler has a ->[^1]gcc option[/^] whether to treat `char` as `signed` or `unsigned`.\\n\\n> -fsigned-char, -funsigned-char, -fno-signed-char\\", -fno-unsigned-char\\n\\nThere are many options, but in the end they are used in two senses.\\n\\n> <b>char -> signed char</b>: -fsigned-char == -fno-unsigned-char<br>\\n> <b>char -> unsigned char</b>: -funsigned-char == -fno-signed-char\\n\\nIt\'s a very simple gcc option, and is also described in detail in the gcc documentation.\\n\\n> #### gcc-7.4.0/C-Dialect-Options\\n> <b>-funsigned-char</b><br>\\n> Let the type `char` be `unsigned`, like `unsigned char</`.<br>\\n> <b>Each kind of machine has a default for what char should be. It is either like unsigned char by default or like signed char by default</b>.<br>\\n> Ideally, a portable program should always use signed char or unsigned char when it depends on the signedness of an object. But many programs have been written to use plain `char` and `expect it to be signed, or expect it to be unsigned`, depending on the machines they were written for. This option, and its inverse, let you make such a program work with the opposite default.<br>\\n> The type char is always a distinct type from each of signed char or unsigned char, even though its behavior is always just like one of those two.<br>\\n> **ref:&nbsp;**<a target=\\"_blank\\" href=\\"https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/C-Dialect-Options.html#C-Dialect-Optionsll\\"><code>https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/C-Dialect-Options.html#C-Dialect-Options</code></a></cite>\\n\\nI haven\'t looked closely at the gcc version where this option first appeared, but gcc 2.8 already includes it.\\n\\n```c\\n: git checkout gcc-2_8_0-release\\n$ cat ./gcc/toplev.c\\n\\nchar *lang_options[] =\\n{\\n\\t...\\n  \\"-fsigned-char\\",\\n  \\"-funsigned-char\\",\\n  \\"-fno-signed-char\\",\\n  \\"-fno-unsigned-char\\",\\n  ...\\n```\\nI can\'t find it in the gcc release notes, but in cpp it seems to have been added to gcc 3.1.\\n\\n```c\\n: git checkout gcc-3_1-release\\n$ cat ./gcc/cppinit.c\\n\\n#define COMMAND_LINE_OPTIONS                                      \\\\\\n....\\n  DEF_OPT(\\"fsigned-char\\",             0,      OPT_fsigned_char)\\n...\\n  DEF_OPT(\\"funsigned-char\\",           0,      OPT_funsigned_char)\\n```\\n\\nLet\'s take a look at the code to see if the option works as intended.\\n\\n```c\\n: sample source code - char.c\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tchar a = (1 << 8) - 1;\\n\\n\\tprintf(\\"%d\\\\n\\", a);\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: gcc version 7.4.0 --target=x86_64-linux-gnu\\n$ gcc -o char char.c \\n$ ./char\\n-1\\n```\\n`x86_64` and my compiler treat `char` as `signed char`.\\nLet\'s add the `-funsigned-char` option.\\n\\n```bash\\n: gcc version 7.4.0 --target=x86_64-linux-gnu\\n$ gcc -funsigned-char -o char char.c \\n$ ./char\\n255\\n```\\nAdded <mark>-funsigned-char</mark> option to make `char` used as `unsigned char`\\nI looked at how each architecture handles `char\' by default.\\n\\n```x86asm\\n: x86_64 - default signed char\\n...\\n 652:\\tc6 45 ff ff          \\tmovb   $0xff,-0x1(%rbp)\\n /* \\n  - movsbl (Move a Sign-extended Byte): signed char\\n  - movzbl (Move a Zero-extended Byte): unsigned char\\n */\\n 656:\\t0f be 45 ff          \\tmovsbl -0x1(%rbp),%eax\\n...\\n```\\n\\n```armasm\\n: aarch64 - default unsigned char\\n...\\n 72c:\\t12800000 \\tmov\\tw0, #0xffffffff            \\t// #-1\\n 730:\\t39007fa0 \\tstrb\\tw0, [x29, #31]\\n /*\\n  - ldrsb (Load Register Signed Byte): signed char\\n  - ldrb (Load Register Byte): unsigned char\\n */\\n 734:\\t39407fa1 \\tldrb\\tw1, [x29, #31]\\n...\\n```\\n```mipsasm\\n: mips64 -default signed char\\n...\\n 10000b20:\\t2402ffff \\tli\\tv0,-1\\n 10000b24:\\ta3c20000 \\tsb\\tv0,0(s8)\\n /*\\n  - lb (Load Byte): signed char\\n  - lbu (Load Byte unsigned): unsigned char\\n */\\n 10000b28:\\t83c20000 \\tlb\\tv0,0(s8)\\n...\\n```\\n```x86asm\\n: ppc - default unsigned char\\n /*\\n  - lis (Load Immediate Shifted): signed char\\n  - li (Load Immediate): unsigned char\\n */\\n 1000046c:\\t38 00 ff ff \\tli      r0,-1\\n 10000470:\\t98 1f 00 0a \\tstb     r0,10(r31)\\n```\\nI found a sample code on stack-overflow to easily check if a `char` is `signed` or `unsigned`.\\n\\n```c\\n: sample code to check if a `char` is `signed` or `unsigned`\\n#include <stdio.h>\\n\\nint main(void) {\\n  printf(\\"%d\\\\n\\", \'\\\\x80\');\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n{% highlight bash %}\\n$ gcc -o simple simple.c \\n$ ./simple\\n-128\\n\\n$ gcc -funsigned-char -o simple simple.c \\n$ ./simple\\n128\\n```\\n\\nIn large projects, compile options are added globally, so it is common to unify the compile options for each process.\\n\\nIn other words, it seems better to write code explicitly using `signed char` or `unsigned char` instead of `char` in code where signed or unsigned is important rather than writing code depending on the compile option.\\n\\n***\\n<ol>\\n\\n[^1] The gcc documentation calls them <b>gcc commands</b>. I will use both terms interchangeably :)\\n\\n</ol>"}')}}]);