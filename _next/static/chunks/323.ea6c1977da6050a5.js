"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[323],{8323:function(t){t.exports=JSON.parse('{"content":"\\n\\n#### Requires\\n: compiler : gcc 2.8.0 later\\n***\\n\\n#### Prior knowledge\\n: gcc options : [-Wformat](/post/2020-11-28-gcc-options-format)\\n\\nAs discussed in the previous post [-Wformat](/post/2020-11-28-gcc-options-format), using <mark>-Wformat</mark> of the gcc option has many advantages because format-related mistakes can be checked at `compile-time` when using glibc functions that deal with arugments such as printf and scanf.\\n\\n\\nIf so, can\'t we get help from <mark>-Wformat</mark> in functions other than glibc functions like printf and scanf?<br>\\nLet\'s say you wrote the following code:\\n\\n```c\\n: sample source code - format\\n#include <stdio.h>\\n#include <stdarg.h>\\n\\nint report(const char *fmt, ...) {\\n\\tva_list arg;\\n\\n\\tva_start(arg, fmt);\\n\\tvfprintf(stderr, fmt, arg);\\n\\tva_end(arg);\\n\\n\\treturn 0;\\n}\\n\\nint main(void) {\\n\\treport(\\"%s\\\\n\\", \\"report!\\", \\"excess\\");\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: Compile with -Wformat\\n$ gcc -o format format.c -Wformat\\n...\\n```\\nCompile was successful without any warning even though the format of the report and the number of arguments did not match.\\n\\nThen, what should I do to support the <mark>-Wformat</mark> of the report() function I wrote?\\n\\nIf you look carefully in the gcc documentation, you will find an `attribute` called <mark>format</mark>.\\n\\n> #### format (archetype, string-index, first-to-check)\\n> The format attribute specifies that a function takes <b>printf, scanf, strftime or strfmon</b> style arguments which should be type-checked against a format string.<br>\\n>...<br>\\n> **ref:&nbsp;**<a target=\\"_blank\\" href=\\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html\\"><code>https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html</code></a></cite>\\n\\nThe explanation is a bit long, so I skipped it all.\\nThe conclusion is that you can use <mark>-Wformat</mark> for any function you want.\\n\\nThen, in the above example code, add <mark>attribute format</mark> and change it to detectable `-Wformat` code at compile-time.\\n```c\\n: sample source code - format.c\\n#include <stdio.h>\\n#include <stdarg.h>\\n\\n__attribute__((format(printf, 1, 2)))\\nint report(const char *fmt, ...) {\\n\\tva_list arg;\\n\\n\\tva_start(arg, fmt);\\n\\tvfprintf(stderr, fmt, arg);\\n\\tva_end(arg);\\n\\n\\treturn 0;\\n}\\n\\nint main(void) {\\n\\treport(\\"%s\\\\n\\", \\"report!\\", \\"excess\\");\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: Compile with -Wformat\\n$ gcc -o format format.c -Wformat\\n\\nformat.c: In function \u2018main\u2019:\\nformat.c:16:9: warning: too many arguments for format [-Wformat-extra-args]\\n   16 |  report(\\"%s\\\\n\\", \\"report!\\", \\"excess\\");\\n      |         ^~~~~~\\n```\\n\\nThe report function I wrote was also detected as a warning by the `-Wformat` option.\\n\\nUsage is simple.\\n```c\\n__attribute__((format(archetype, string-index, first-to-check)))\\n```\\n\\nYou can use `printf`, `scanf`, `strftime` for archetype. Depending on the target, gnu_* of glibc may be attached, or ms_* of MinGW may be attached.\\n\\nFor string-index, specify the position of `format argument`. The important thing is that the index starts at 1, not 0. In the example function `int report(const char *fmt, ...)`, we specified 1 because `fmt` is the first argument.\\n\\nFor first-to-check, you can specify the position in the argument.\\n\\nNote that\\nFor functions with no argument(like ...), such as `vprintf`, you can set `first-to-check` to 0.\\n\\n```c\\n: sample source code - format_vprintf.c\\n#include <stdio.h>\\n#include <stdarg.h>\\n\\n__attribute__((format(printf, 2, 0)))\\nint _va_report(int n, const char *fmt, va_list ap) {\\n    return vfprintf(stdout, fmt, ap);\\n}\\n\\nint report(int n, ...) {\\n\\tva_list arg;\\n\\n\\tva_start(arg, n);\\n  _va_report(n, \\"%s\\\\0\\\\n\\", arg);\\n\\tva_end(arg);\\n\\n\\treturn 0;\\n}\\n\\nint main(void) {\\n  report(2, \\"1\\");\\n\\treturn 0;\\n}\\n```\\n```bash\\n: Compile with -Wformat\\n$ gcc -o format_vprintf format_vprintf.c -Wformat\\n\\nformat_vprintf.c: In function \u2018report\u2019:\\nformat_vprintf.c:13:22: warning: embedded \u2018\\\\0\u2019 in format [-Wformat-contains-nul]\\n   13 |     _va_report(n, \\"%s\\\\0\\\\n\\", arg);\\n      |                      ^~\\n```\\nIn this case, we only check the format.\\nIn other words, the following code cannot be detected.\\n```c\\n: -Wformat-extra-args is not detected\\n#include <stdio.h>\\n#include <stdarg.h>\\n\\n__attribute__((format(printf, 2, 0)))\\nint _va_report(int n, const char *fmt, va_list ap) {\\n    return vfprintf(stdout, fmt, ap);\\n}\\n\\nint report(int n, ...) {\\n\\tva_list arg;\\n\\n\\tva_start(arg, n);\\n  _va_report(n, \\"%s\\\\n\\", arg);\\n\\tva_end(arg);\\n\\n\\treturn 0;\\n}\\n\\nint main(void) {\\n  report(3, \\"1\\", \\"2\\", \\"3\\");\\n\\treturn 0;\\n}\\n```\\n```bash\\n: Compile with -Wformat-extra-args, but not detected\\n$ gcc -o format_vprintf format_vprintf.c -Wformat -Wformat-extra-args\\n...\\n```\\nThe same goes for `strtime`. Used with `first-to-check` set to 0.\\n```c\\n: sample source code - strftime.c\\n#include <stdio.h>\\n#include <time.h>\\n\\n__attribute__((format(strftime, 1, 0)))\\nvoid get_time(const char *fmt, struct tm * tptr) {\\n    char buf[64];\\n\\n    strftime(buf, sizeof(buf), fmt, tptr);\\n    puts(buf);\\n}\\n\\nint main(void) {\\n    time_t tmp;\\n    struct tm *tptr;\\n\\n    tmp = time(NULL);\\n    tptr = localtime(&tmp);\\n\\n    get_time(\\"%A, %b %d.\\\\nTime: %r..%i?\\", tptr);\\n\\n    return 0;\\n}\\n```\\n```bash\\n: Compile with -Wformat\\n$ gcc -o strftime strftime.c -Wformat\\n\\nstrftime.c: In function \u2018main\u2019:\\nstrftime.c:19:38: warning: unknown conversion type character \u2018i\u2019 in format [-Wformat=]\\n   19 |     get_time(\\"%A, %b %d.\\\\nTime: %r..%i?\\", tptr);\\n      |                                      ^\\n```\\nYou can also set the attribute in the function declaration.\\n```c\\nint report(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\\n```\\n\\nThis attribute is an old attribute that has already been included since `gcc 2.8.0 release`.\\n```c\\n: gcc 2.8.0 release - c-common.c\\nstatic void\\ninit_attributes ()\\n{\\n  ...\\n  add_attribute (A_FORMAT, \\"format\\", 3, 3, 1);\\n  add_attribute (A_FORMAT_ARG, \\"format_arg\\", 1, 1, 1);\\n  ...\\n}\\n\\nvoid\\ndecl_attributes (node, attributes, prefix_attributes)\\n     tree node, attributes, prefix_attributes;\\n{\\n  ...\\n  case A_FORMAT:\\n  {\\n    ...\\n    if (TREE_CODE (format_type) == IDENTIFIER_NODE\\n\\t\\t&& (!strcmp (IDENTIFIER_POINTER (format_type), \\"printf\\")\\n\\t\\t    || !strcmp (IDENTIFIER_POINTER (format_type),\\n\\t\\t\\t\\t\\"__printf__\\")))\\n\\t      is_scan = 0;\\n\\t    else if (TREE_CODE (format_type) == IDENTIFIER_NODE\\n\\t\\t     && (!strcmp (IDENTIFIER_POINTER (format_type), \\"scanf\\")\\n\\t\\t\\t || !strcmp (IDENTIFIER_POINTER (format_type),\\n\\t\\t\\t\\t     \\"__scanf__\\")))\\n\\t      is_scan = 1;\\n\\t    else if (TREE_CODE (format_type) == IDENTIFIER_NODE)\\n\\t      {\\n\\t\\terror (\\"`%s\' is an unrecognized format function type\\",\\n\\t\\t       IDENTIFIER_POINTER (format_type));\\n\\t\\tcontinue;\\n\\t      }\\n\\t    else\\n\\t      {\\n\\t\\terror (\\"unrecognized format specifier\\");\\n\\t\\tcontinue;\\n\\t      }\\n  ...\\n}\\n```\\nAt this time only archetypes `printf` and `scanf` were supported.\\n\\n`strftime` was added to `gcc-2.9`.\\n```diff\\n: release/gcc-2.95 - cat This-change-is-from-an-idea-suggested-by-Arthur-Davi.patch\\n+\\t* c-common.c (decl_attributes, record_function_format,\\n+\\tcheck_format_info, init_function_format_info):\\n+\\tAdd support for strftime format checking.\\n...\\n+\\t\\tchar *p = IDENTIFIER_POINTER (format_type_id);\\n+\\t\\t\\n+\\t\\tif (!strcmp (p, \\"printf\\") || !strcmp (p, \\"__printf__\\"))\\n+\\t\\t  format_type = printf_format_type;\\n+\\t\\telse if (!strcmp (p, \\"scanf\\") || !strcmp (p, \\"__scanf__\\"))\\n+\\t\\t  format_type = scanf_format_type;\\n+\\t\\telse if (!strcmp (p, \\"strftime\\")\\n+\\t\\t\\t || !strcmp (p, \\"__strftime__\\"))\\n+\\t\\t  format_type = strftime_format_type;\\n+\\t\\telse\\n+\\t\\t  {\\n+\\t\\t    error (\\"`%s\' is an unrecognized format function type\\", p);\\n+\\t\\t    continue;\\n+\\t\\t  }\\n```\\n***\\n#### format_arg\\nIf you look at the gcc code and documentation, you will also see an `attribute` called `format_arg`.\\nThis attribute also works the same as `format attribute`.\\nThe difference is that you use it in functions that only have `format`.\\n\\nFor example, you can create a function that adds a prefix to the format string like this:\\nIn this case you can use `format_arg`\\n```c\\n: sample source code - format_arg.c\\n#include <stdio.h>\\n\\n__attribute__((format_arg(3)))\\nchar *debug_format(char *buf, size_t len, char *fmt) {\\n    snprintf(buf, len, \\"[debug] %s\\", fmt);\\n\\n    return buf;\\n}\\n\\nint main(void) {\\n    char buf[32];\\n\\n    printf(debug_format(buf, sizeof(buf), \\"%s\\\\n\\"), \\"arg1\\", \\"excess\\");\\n\\n    return 0;\\n}\\n```\\n```bash\\n: Compile with -Wformat\\n$ gcc -o format_arg format_arg.c -Wformat\\n\\nformat_arg.c: In function \u2018main\u2019:\\nformat_arg.c:13:43: warning: too many arguments for format [-Wformat-extra-args]\\n   13 |     printf(debug_format(buf, sizeof(buf), \\"%s\\\\n\\"), \\"arg1\\", \\"excess\\");\\n      |                                           ^~~~~~\\n```\\nPersonally, I think that <mark>-Wformat</mark> is a powerful option that can detect problems that may occur at run-time in advance at compile-time.\\nSo, when writing code, if possible, add <mark>-Werror=format</mark> to generate a compile error.\\n\\nHowever, in fact, when writing code, there are many times when I forget to add `-Wformat` related attribute to my code.\\n\\nFor this, gcc also provides an option called `-Wmissing-format-attribute`.\\nI plan to write an additional post about `-Wmissing-format-attribute` as well.\\n\\nThe conclusion is the same as when `-Wformat`. It is recommended to use the <mark>format attribute</mark> a lot to solve predictable problems at compile-time in advance."}')}}]);