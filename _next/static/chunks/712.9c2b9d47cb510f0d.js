"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[712],{1712:function(n){n.exports=JSON.parse('{"content":"\\n\\n#### Requires\\n: -finstrument-functions : gcc 3.0 later\\n: no_instrument_function : gcc 3.0 later\\n: -finstrument-functions-exclude-* : gcc 4.3 later\\n: glibc : 2.1 later\\n***\\n\\nThere is a `constructor/destructor` attribute that was called before the main function call and after the process ended.\\nSimilarly, there is a gcc option called <mark>-finstrument-functions</mark> that allows you to `hook the entry and exit` of any function.\\n\\nThis option can be quite useful for `debugging or profiling`. I want to learn more.\\n\\nUsing this option is fairly straightforward.\\nAll you have to do is put the option at build time as CFLAGS.\\n\\nLet\'s write the sample code and build it using the option.\\n```c\\n: usage - usage.c\\n#include <stdio.h>\\n\\nvoid b() {\\n\\tprintf(\\"nope!, I\'m b\\\\n\\");\\n}\\n\\nvoid a() {\\n\\tprintf(\\"I\'m a\\\\n\\");\\n}\\n\\nint main(void) {\\n\\ta();\\n\\tb();\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -g -o usage usage.c -finstrument-functions\\n\\n$ ./usage\\nI\'m a\\nnope!, I\'m b\\n```\\nEven if you put options and build, there is no change in the result in this state.\\nLet\'s check what has changed through `gdb`.\\n```x86asm\\n$ gdb ./usage\\nReading symbols from ./usage...\\n(gdb) disassemble main\\nDump of assembler code for function main:\\n ...\\n   0x0000000000001210 <+13>:\\tmov    0x8(%rbp),%rax\\n   0x0000000000001214 <+17>:\\tmov    %rax,%rsi\\n   0x0000000000001217 <+20>:\\tlea    -0x1b(%rip),%rdi        # 0x1203 <main>\\n   0x000000000000121e <+27>:\\tcallq  0x1090 <__cyg_profile_func_enter@plt>\\n   0x0000000000001223 <+32>:\\tmov    $0x0,%eax\\n   0x0000000000001228 <+37>:\\tcallq  0x11c6 <a>\\n   0x000000000000122d <+42>:\\tmov    $0x0,%eax\\n   0x0000000000001232 <+47>:\\tcallq  0x1189 <b>\\n   0x0000000000001237 <+52>:\\tmov    $0x0,%ebx\\n   0x000000000000123c <+57>:\\tmov    0x8(%rbp),%rax\\n   0x0000000000001240 <+61>:\\tmov    %rax,%rsi\\n   0x0000000000001243 <+64>:\\tlea    -0x47(%rip),%rdi        # 0x1203 <main>\\n   0x000000000000124a <+71>:\\tcallq  0x1080 <__cyg_profile_func_exit@plt>\\n...\\n(gdb) disassemble a\\nDump of assembler code for function a:\\n   0x00000000000011c6 <+0>:\\tendbr64 \\n   0x00000000000011ca <+4>:\\tpush   %rbp\\n   0x00000000000011cb <+5>:\\tmov    %rsp,%rbp\\n   0x00000000000011ce <+8>:\\tmov    0x8(%rbp),%rax\\n   0x00000000000011d2 <+12>:\\tmov    %rax,%rsi\\n   0x00000000000011d5 <+15>:\\tlea    -0x16(%rip),%rdi        # 0x11c6 <a>\\n   0x00000000000011dc <+22>:\\tcallq  0x1090 <__cyg_profile_func_enter@plt>\\n   0x00000000000011e1 <+27>:\\tlea    0xe29(%rip),%rdi        # 0x2011\\n   0x00000000000011e8 <+34>:\\tcallq  0x1070 <puts@plt>\\n   0x00000000000011ed <+39>:\\tmov    0x8(%rbp),%rax\\n   0x00000000000011f1 <+43>:\\tmov    %rax,%rsi\\n   0x00000000000011f4 <+46>:\\tlea    -0x35(%rip),%rdi        # 0x11c6 <a>\\n   0x00000000000011fb <+53>:\\tcallq  0x1080 <__cyg_profile_func_exit@plt>\\n   0x0000000000001200 <+58>:\\tnop\\n   0x0000000000001201 <+59>:\\tpop    %rbp\\n   0x0000000000001202 <+60>:\\tretq   \\nEnd of assembler dump.\\n(gdb) disassemble b\\nDump of assembler code for function b:\\n   0x0000000000001189 <+0>:\\tendbr64 \\n   0x000000000000118d <+4>:\\tpush   %rbp\\n   0x000000000000118e <+5>:\\tmov    %rsp,%rbp\\n   0x0000000000001191 <+8>:\\tmov    0x8(%rbp),%rax\\n   0x0000000000001195 <+12>:\\tmov    %rax,%rsi\\n   0x0000000000001198 <+15>:\\tlea    -0x16(%rip),%rdi        # 0x1189 <b>\\n   0x000000000000119f <+22>:\\tcallq  0x1090 <__cyg_profile_func_enter@plt>\\n   0x00000000000011a4 <+27>:\\tlea    0xe59(%rip),%rdi        # 0x2004\\n   0x00000000000011ab <+34>:\\tcallq  0x1070 <puts@plt>\\n   0x00000000000011b0 <+39>:\\tmov    0x8(%rbp),%rax\\n   0x00000000000011b4 <+43>:\\tmov    %rax,%rsi\\n   0x00000000000011b7 <+46>:\\tlea    -0x35(%rip),%rdi        # 0x1189 <b>\\n   0x00000000000011be <+53>:\\tcallq  0x1080 <__cyg_profile_func_exit@plt>\\n   0x00000000000011c3 <+58>:\\tnop\\n   0x00000000000011c4 <+59>:\\tpop    %rbp\\n   0x00000000000011c5 <+60>:\\tretq   \\nEnd of assembler dump.\\n```\\nCall the <mark>__cyg_profile_func_enter</mark> and <mark>__cyg_profile_func_exit</mark> functions not only in the `main function` but also in the `a and b functions`.\\n\\nLooking at the function, it currently does nothing.\\nIf you look at the <mark>__cyg_profile_func_enter</mark> function after being called by the `PLT`, it is an empty function that does not currently do anything.\\n\\n```x86asm\\n: glibc - __cyg_profile_func_enter\\n(gdb) disassemble __cyg_profile_func_enter\\nDump of assembler code for function __cyg_profile_func_enter:\\n   0x00007fffff6d08d0 <+0>:\\tendbr64 \\n   0x00007fffff6d08d4 <+4>:\\tretq   \\nEnd of assembler dump.\\n```\\nLet\'s get to the bottom of <mark>__cyg_profile_func_enter</mark> and <mark>__cyg_profile_func_exit</mark> in glibc code.\\n```c\\n: what is __cyg_profile_func_* - debug/noophooks.c\\nvoid\\n__cyg_profile_func_enter (void *this_fn, void *call_site)\\n{\\n}\\nstrong_alias (__cyg_profile_func_enter, __cyg_profile_func_exit)\\n```\\nAs expected, it is a dummy function and has no implementation.\\n\\nFor reference, the <mark>strong alias</mark> is an alias of <mark>__cyg_profile_func_exit</mark> to <mark>__cyg_profile_func_enter</mark> using the `alias attribute`, and it can be considered that it as pointing to the same function.\\n> When outputting as __FUNC__, the original function name is output, not the alias function name. I will post about it when I get a chance.\\n\\nSo, what are the function arguments <mark>*this_fn</mark> and <mark>*call_site</mark>?\\nIf you look at disassemble, you can find the answer on what value to set as an argument before calling a function.\\n```x86asm\\n: What value is entered in argumnent - a function disassemble\\n(gdb) disassemble a\\nDump of assembler code for function a:\\n   0x00000000000011c6 <+0>:\\tendbr64 \\n   0x00000000000011ca <+4>:\\tpush   %rbp\\n   0x00000000000011cb <+5>:\\tmov    %rsp,%rbp\\n   0x00000000000011ce <+8>:\\tmov    0x8(%rbp),%rax\\n   // rsi (call_site) = stack + 0x8 => return address\\n   0x00000000000011d2 <+12>:\\tmov    %rax,%rsi\\n   // rdi (this_fn) = current function address\\n   0x00000000000011d5 <+15>:\\tlea    -0x16(%rip),%rdi        # 0x11c6 <a>\\n   0x00000000000011dc <+22>:\\tcallq  0x1090 <__cyg_profile_func_enter@plt>\\n   0x00000000000011e1 <+27>:\\tlea    0xe29(%rip),%rdi        # 0x2011\\n   0x00000000000011e8 <+34>:\\tcallq  0x1070 <puts@plt>\\n   0x00000000000011ed <+39>:\\tmov    0x8(%rbp),%rax\\n   0x00000000000011f1 <+43>:\\tmov    %rax,%rsi\\n   0x00000000000011f4 <+46>:\\tlea    -0x35(%rip),%rdi        # 0x11c6 <a>\\n   0x00000000000011fb <+53>:\\tcallq  0x1080 <__cyg_profile_func_exit@plt>\\n   0x0000000000001200 <+58>:\\tnop\\n   0x0000000000001201 <+59>:\\tpop    %rbp\\n   0x0000000000001202 <+60>:\\tretq   \\nEnd of assembler dump.\\n```\\n<mark>rdi (this_fn)</mark> contains the address of the `current function`, and <mark>rsi (call_site)</mark> contains the `return address (LR)`.\\n\\nLet\'s print the value once. Let\'s generate the following code, compile and run it.\\n```c\\n: add __cyg_profile_func* - check_argument.c\\n#include <stdio.h>\\n\\nvoid __cyg_profile_func_enter (void *this_fn, void *call_site) {\\n\\tprintf(\\"%p %p\\\\n\\", this_fn, call_site);\\n}\\n\\nvoid __cyg_profile_func_exit (void *this_fn, void *call_site) {\\n\\tprintf(\\"%p %p\\\\n\\", this_fn, call_site);\\n}\\n\\nvoid b() {\\n\\tprintf(\\"nope!, I\'m b\\\\n\\");\\n}\\n\\nvoid a() {\\n\\tprintf(\\"I\'m a\\\\n\\");\\n}\\n\\nint main(void) {\\n\\ta();\\n\\tb();\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: check result\\n$ gcc -g -o check_argument check_argument.c -finstrument-functions\\n\\n$ ./check_argument\\nSegmentation fault (core dumped)\\n```\\nYes!! A segmentation fault occurs. Why?\\nTake a look with `gdb` and you\'ll see why.\\n```x86asm\\n: segmentation fault\\n(gdb) disassemble __cyg_profile_func_enter\\nDump of assembler code for function __cyg_profile_func_enter:\\n   0x0000000000001169 <+0>:\\tendbr64 \\n   0x000000000000116d <+4>:\\tpush   %rbp\\n   0x000000000000116e <+5>:\\tmov    %rsp,%rbp\\n   0x0000000000001171 <+8>:\\tsub    $0x10,%rsp\\n   0x0000000000001175 <+12>:\\tmov    %rdi,-0x8(%rbp)\\n   0x0000000000001179 <+16>:\\tmov    %rsi,-0x10(%rbp)\\n   0x000000000000117d <+20>:\\tmov    0x8(%rbp),%rax\\n   0x0000000000001181 <+24>:\\tmov    %rax,%rsi\\n   // recursive call\\n   0x0000000000001184 <+27>:\\tlea    -0x22(%rip),%rdi        # 0x1169 <__cyg_profile_func_enter>\\n   0x000000000000118b <+34>:\\tcallq  0x1169 <__cyg_profile_func_enter>\\n   0x0000000000001190 <+39>:\\tmov    -0x10(%rbp),%rdx\\n   0x0000000000001194 <+43>:\\tmov    -0x8(%rbp),%rax\\n   0x0000000000001198 <+47>:\\tmov    %rax,%rsi\\n   0x000000000000119b <+50>:\\tlea    0xe62(%rip),%rdi        # 0x2004\\n   0x00000000000011a2 <+57>:\\tmov    $0x0,%eax\\n   0x00000000000011a7 <+62>:\\tcallq  0x1070 <printf@plt>\\n   0x00000000000011ac <+67>:\\tmov    0x8(%rbp),%rax\\n   0x00000000000011b0 <+71>:\\tmov    %rax,%rsi\\n   0x00000000000011b3 <+74>:\\tlea    -0x51(%rip),%rdi        # 0x1169 <__cyg_profile_func_enter>\\n   0x00000000000011ba <+81>:\\tcallq  0x11c2 <__cyg_profile_func_exit>\\n   0x00000000000011bf <+86>:\\tnop\\n   0x00000000000011c0 <+87>:\\tleaveq \\n   0x00000000000011c1 <+88>:\\tretq   \\nEnd of assembler dump.\\n```\\nLooking at the <mark>__cyg_profile_func_enter</mark> function will call <mark>__cyg_profile_func_enter</mark> again.\\nFor gcc, the <mark>__cyg_profile_func_enter</mark> function is also a hooking target function, so it is ultimately called `recursive` and eventually a `stack overflow` will occur.\\n\\nLet\'s look at the gcc code to find a solution.\\n```c\\n: See how the gcc code handles it - ./gcc/gimplify.c\\n  if (flag_instrument_function_entry_exit\\n      && !DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (fndecl)\\n      /* Do not instrument extern inline functions.  */\\n      && !(DECL_DECLARED_INLINE_P (fndecl)\\n\\t   && DECL_EXTERNAL (fndecl)\\n\\t   && DECL_DISREGARD_INLINE_LIMITS (fndecl))\\n      && !flag_instrument_functions_exclude_p (fndecl))\\n    {\\n...\\n```\\n`extern inline` functions and `external functions` have exception handling.\\n\\nAlso, <mark>DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT()</mark> and <mark>flag_instrument_functions_exclude_p()</mark> have exception handling.\\nLet\'s look at the code.\\n```c\\n: DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT - ./gcc/c-family/c-attribs.c\\nconst struct attribute_spec c_common_attribute_table[] =\\n{\\n...\\n  { \\"no_instrument_function\\", 0, 0, true,  false, false, false,\\n\\t\\t\\t      handle_no_instrument_function_attribute,\\n\\t\\t\\t      NULL },\\n\\n...\\nstatic tree\\nhandle_no_instrument_function_attribute (tree *node, tree name,\\n\\t\\t\\t\\t\\t tree ARG_UNUSED (args),\\n\\t\\t\\t\\t\\t int ARG_UNUSED (flags),\\n\\t\\t\\t\\t\\t bool *no_add_attrs)\\n{\\n...\\n    DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\\n```\\nIt is said that if you use the <mark>no_instrument_function</mark> attribute, an exception is handled.\\nLet\'s add an attribute.\\n```c\\n: add no_instrument_function attribute - attribute.c\\n#include <stdio.h>\\n\\n__attribute__((no_instrument_function))\\nvoid __cyg_profile_func_enter (void *this_fn, void *call_site) {\\n\\tprintf(\\"%s %p %p\\\\n\\", __func__, this_fn, call_site);\\n}\\n\\n__attribute__((no_instrument_function))\\nvoid __cyg_profile_func_exit (void *this_fn, void *call_site) {\\n\\tprintf(\\"%s %p %p\\\\n\\", __func__, this_fn, call_site);\\n}\\n\\nvoid b() {\\n\\tprintf(\\"nope!, I\'m b\\\\n\\");\\n}\\n\\nvoid a() {\\n\\tprintf(\\"I\'m a\\\\n\\");\\n}\\n\\nint main(void) {\\n\\ta();\\n\\tb();\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -g -o attribute attribute.c -finstrument-functions\\n\\n$ ./attribute\\n__cyg_profile_func_enter 0x7ff1f8ff925d 0x7ff1f8dd70b3\\n__cyg_profile_func_enter 0x7ff1f8ff9220 0x7ff1f8ff9287\\nI\'m a\\n__cyg_profile_func_exit 0x7ff1f8ff9220 0x7ff1f8ff9287\\n__cyg_profile_func_enter 0x7ff1f8ff91e3 0x7ff1f8ff9291\\nnope!, I\'m b\\n__cyg_profile_func_exit 0x7ff1f8ff91e3 0x7ff1f8ff9291\\n__cyg_profile_func_exit 0x7ff1f8ff925d 0x7ff1f8dd70b3\\n```\\nThe addition of the <mark>no_instrument_function</mark> attribute has been excluded from the hooking target function.\\n\\nNow let\'s look at <mark>flag_instrument_functions_exclude_p()</mark> in gcc code.\\n```c\\n: flag_instrument_functions_exclude_p - gcc/gimplify.c\\nstatic bool\\nflag_instrument_functions_exclude_p (tree fndecl)\\n{\\n  vec<char_p> *v;\\n\\n  v = (vec<char_p> *) flag_instrument_functions_exclude_functions;\\n  if (v && v->length () > 0)\\n    {\\n...\\n    }\\n\\n  v = (vec<char_p> *) flag_instrument_functions_exclude_files;\\n  if (v && v->length () > 0)\\n    {\\n...\\n    }\\n\\n  return false;\\n}\\n```\\n```c\\n: common_handle_option - gcc/opts.c\\nbool\\ncommon_handle_option (struct gcc_options *opts,\\n\\t\\t      struct gcc_options *opts_set,\\n\\t\\t      const struct cl_decoded_option *decoded,\\n\\t\\t      unsigned int lang_mask, int kind ATTRIBUTE_UNUSED,\\n\\t\\t      location_t loc,\\n\\t\\t      const struct cl_option_handlers *handlers,\\n\\t\\t      diagnostic_context *dc,\\n\\t\\t      void (*target_option_override_hook) (void))\\n{\\n...\\n    case OPT_finstrument_functions_exclude_function_list_:\\n      add_comma_separated_to_vector\\n\\t(&opts->x_flag_instrument_functions_exclude_functions, arg);\\n      break;\\n\\n    case OPT_finstrument_functions_exclude_file_list_:\\n      add_comma_separated_to_vector\\n\\t(&opts->x_flag_instrument_functions_exclude_files, arg);\\n      break;\\n```\\n\\nFunctions and files set with <mark>-finstrument_functions_exclude_function_list</mark> and <mark>-finstrument_functions_exclude_file_list</mark> are also excluded from the target function.\\n\\nI tested the <mark>-finstrument-functions-exclude-function-list</mark> option.\\n```bash\\n: use -finstrument-functions-exclude-function-list - check_argument.c\\n$ gcc -g -o check_argument check_argument.c \\\\\\n\\t-finstrument-functions \\\\\\n\\t-finstrument-functions-exclude-function-list=\'__cyg_profile_func_enter,__cyg_profile_func_exit,b\'\\n\\n$ ./check_argument\\n0x7f78addd2223 0x7f78adba70b3\\n0x7f78addd21e6 0x7f78addd224d\\nI\'m a\\n0x7f78addd21e6 0x7f78addd224d\\nnope!, I\'m b\\n0x7f78addd2223 0x7f78adba70b3\\n```\\nAdding function names to the list makes them excluded from hooking targets.\\n\\nLet\'s also look at <mark>-finstrument-functions-exclude-file-list</mark>.\\n```c\\n: use -finstrument-functions-exclude-file-list - exclude_file_list.c\\n#include <stdio.h>\\n\\nextern void b();\\n\\nvoid a() {\\n\\tprintf(\\"I\'m a\\\\n\\");\\n}\\n\\nint main(void) {\\n\\ta();\\n\\tb();\\n\\n\\treturn 0;\\n}\\n```\\n```c\\n: use -finstrument-functions-exclude-file-list - extern.c\\n#include <stdio.h>\\n\\nvoid __cyg_profile_func_enter (void *this_fn, void *call_site) {\\n\\tprintf(\\"%p %p\\\\n\\", this_fn, call_site);\\n}\\n\\nvoid __cyg_profile_func_exit (void *this_fn, void *call_site) {\\n\\tprintf(\\"%p %p\\\\n\\", this_fn, call_site);\\n}\\n\\nvoid b() {\\n\\tprintf(\\"nope!, I\'m b\\\\n\\");\\n}\\n```\\n```bash\\n: result - build with -finstrument-functions-exclude-file-list\\n$ gcc -g -o exclude_file_list exclude_file_list.c extern.c \\\\\\n\\t-finstrument-functions \\\\\\n\\t-finstrument-functions-exclude-file-list=\'extern.c\'\\n\\n$ ./exclude_file_list\\n0x7ff5ca9471a6 0x7ff5ca7270b3\\n0x7ff5ca947169 0x7ff5ca9471d0\\nI\'m a\\n0x7ff5ca947169 0x7ff5ca9471d0\\nnope!, I\'m b\\n0x7ff5ca9471a6 0x7ff5ca7270b3\\n```\\nAll functions in `extern.c` are excluded from the hooking target.\\n\\nA commonly used use-case is to implement <mark>__cyg_profile_func_enter</mark> and <mark>__cyg_profile_func_exit</mark> as debugging code and build it in dynamic library and execute them together with the binary rebuilt by <mark>-finstrument-functions</mark> and <mark>LD_PRELOAD</mark>.\\n```c\\n: dynamic library - hook.so\\n#include <stdio.h>\\n\\nvoid __cyg_profile_func_enter (void *this_fn, void *call_site) {\\n\\tprintf(\\"%p %p\\\\n\\", this_fn, call_site);\\n}\\n\\nvoid __cyg_profile_func_exit (void *this_fn, void *call_site) {\\n\\tprintf(\\"%p %p\\\\n\\", this_fn, call_site);\\n}\\n```\\n```bash\\n: build - hook.so\\n$ gcc -shared -fPIC -o hook.so hook.c\\n```\\nRe-build binaries that need debugging with <mark>-finstrument-functions</mark>.\\n```c\\n: run with option - binary.c\\n#include <stdio.h>\\n\\nvoid b() {\\n\\tprintf(\\"nope!, I\'m b\\\\n\\");\\n}\\n\\nvoid a() {\\n\\tprintf(\\"I\'m a\\\\n\\");\\n}\\n\\nint main(void) {\\n\\ta();\\n\\tb();\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: build with option\\n$ gcc -o binary binary.c -finstrument-functions\\n\\n$ LD_PRELOAD=`pwd`/hook.so ./binary\\n0x7f89a0d9a203 0x7f89a0b670b3\\n0x7f89a0d9a1c6 0x7f89a0d9a22d\\nI\'m a\\n0x7f89a0d9a1c6 0x7f89a0d9a22d\\n0x7f89a0d9a189 0x7f89a0d9a237\\nnope!, I\'m b\\n0x7f89a0d9a189 0x7f89a0d9a237\\n0x7f89a0d9a203 0x7f89a0b670b3\\n```\\nThere are various ways to use it. You can also measure the execution time of a function or check the stack usage of a process.\\nIn addition, it will be possible to easily check the function call relationship.\\nOf course, since function calls are added to the code, performance measurements should take this into account when interpreting the results.\\n\\nPlease remember that there is a simple method for `dynamic analysis` like this, and use it appropriately."}')}}]);