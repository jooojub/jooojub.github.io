"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[506],{9506:function(n){n.exports=JSON.parse('{"content":"\\n\\n#### Requires\\n: compiler : gcc 4.0 later\\n***\\n\\nBasically, when writing and providing a dynamic library, all `non-static` functions are exposed to the outside.\\nFunctions that you don\'t want to be public can be declared `static` to limit the scope, but depending on the code structure, this may not be possible.\\nFor example, it is a shared symbol within the library code, but since `static` cannot be used in situations where you do not want to expose it outside the library, the symbol is exposed to the outside.\\nIn other words, access restrictions are limited only with `static` keyword.\\n\\nFor these situations, `ELF` has a <mark>Symbol Binding</mark> field for symbol management.\\n\\nThis is the content of <mark>Symbol Binding</mark> in the ELF specification document.\\n\\n> #### ELF / Symbol Binding<br>\\n> <b>STB_LOCAL</b>\\n> Local symbols are not visible outside the object file containing their definition. Local symbols of the same name may exist in multiple files without interfering with each other.<br><br>\\n> <b>STB_GLOBAL</b>\\n> Global symbols are visible to all object files being combined. One file\'s definition of a global symbol will satisfy another file\'s undefined reference to the same global symbol.<br><br>\\n> <b>STB_WEAK</b>\\n> Weak symbols resemble global symbols, but their definitions have lower precedence.\\n\\nAs you can easily guess from the name, there is a <mark>local</mark> to keep the symbol <mark>private</mark> to the outside, on the contrary, a <mark>global</mark> that can be exposed.\\n\\n`Weak` is <mark>public</mark> like <mark>global</mark> but can be overridden. I will discuss `weak` in another post later.\\n\\nELF also has a <mark>Symbol Visibility</mark> field.\\n\\n> #### ELF / Symbol Visibility<br>\\n> <b>STV_DEFAULT</b>\\n> The visibility of symbols with the <b>STV_DEFAULT</b> attribute is as specified by the symbol\'s binding type. That is, global and weak symbols are visible outside of their defining component, the executable file or shared object. Local symbols are hidden. Global and weak symbols can also be preempted, that is, they may by interposed by definitions of the same name in another component.<br><br>\\n> <b>STV_PROTECTED</b>\\n> A symbol defined in the current component is protected if it is visible in other components but cannot be preempted. Any reference to such a symbol from within the defining component must be resolved to the definition in that component, even if there is a definition in another component that would interpose by the default rules. A symbol with STB_LOCAL binding will not have STV_PROTECTED visibility.<br><br>\\n> <b>STV_HIDDEN</b>\\n> A symbol defined in the current component is hidden if its name is not visible to other components. Such a symbol is necessarily protected. This attribute is used to control the external interface of a component. An object named by such a symbol may still be referenced from another component if its address is passed outside.\\n> A hidden symbol contained in a relocatable object is either removed or converted to <b>STB_LOCAL</b> binding by the link-editor when the relocatable object is included in an executable file or shared object.<br><br>\\n> <b>STV_INTERNAL</b>\\n> This visibility attribute is currently reserved.\\n\\n`STV_HIDDEN` is used by replacing `STB_LOCAL` of <mark>Symbol Binding</mark>, and it is said that it is not used as `STV_INTERNAL`.\\nThat is, all except `protected` are <mark>STV_DEFAULT</mark>.\\n\\nTo set this, gcc provides a <mark>visibility</mark> attribute.\\n> __attribute__ ((visibility (visibility_type)))\\n\\nThere are 4-types of <mark>visibility_type</mark>.\\n\\n> #### visibility_type<br>\\n> <b>default</b>\\n> Default visibility is the normal case for ELF. This value is available for the visibility attribute to override other options that may change the assumed visibility of symbols.<br><br>\\n> <b>hidden</b>\\n> Hidden visibility indicates that the symbol <b>will not be placed into the dynamic symbol table</b>, so no other module (executable or shared library) can reference it directly.<br><br>\\n> <b>internal</b>\\n> Internal visibility is like <b>hidden</b> visibility, but with additional <b>processor specific</b> semantics. Unless otherwise specified by the psABI, GCC defines internal visibility to mean that the function is never called from another module. Note that hidden symbols, while they cannot be referenced directly by other modules, can be referenced indirectly via function pointers. By indicating that a symbol cannot be called from outside the module, GCC may for instance omit the load of a PIC register since it is known that the calling function loaded the correct value.<br><br>\\n> <b>protected</b>\\n> Protected visibility indicates that the symbol <b>will be placed in the dynamic symbol table</b>, but that references within the defining module will bind to the local symbol. That is, the <b>symbol cannot be overridden</b> by another module.\\n***\\n<mark>default</mark> exposes symbols externally. \\nThat is, the <mark>Symbol Binding</mark> type is set to <mark>STB_GLOBAL</mark>.\\n\\nYou can hide all symbols without a visibiitly attribute by using <mark>-fvisibility=hidden</mark>, but the symbols defined by <mark>default</mark> are made public.\\n\\n```c\\n: default - default.c\\n#include <stdio.h>\\n\\n__attribute__((visibility(\\"default\\")))\\nvoid default_func_a(int value) {\\n\\tprintf(\\"value: %d\\\\n\\", value);\\n}\\n\\nvoid default_func_b(int value) {\\n\\tprintf(\\"value: %d\\\\n\\", value);\\n}\\n\\nint main(void) {\\n\\tdefault_func_a(10);\\n\\tdefault_func_b(20);\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -fvisibility=hidden -o default default.c\\n\\n$ readelf --syms default | grep func\\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n    40: 0000000000001171    40 FUNC    LOCAL  DEFAULT   16 default_func_b\\n    63: 0000000000001149    40 FUNC    GLOBAL DEFAULT   16 default_func_a\\n```\\nOf course, a function defined as <mark>static</mark> is not public even if it is defined as <mark>default</mark>, and gcc notifies it as a `warning`.\\n\\n```c\\n: default - default_static.c\\n#include <stdio.h>\\n\\n__attribute__((visibility(\\"default\\")))\\nvoid default_func_a(int value) {\\n\\tprintf(\\"value: %d\\\\n\\", value);\\n}\\n\\n__attribute__((visibility(\\"default\\")))\\nstatic void default_func_b(int value) {\\n\\tprintf(\\"value: %d\\\\n\\", value);\\n}\\n\\nint main(void) {\\n\\tdefault_func_a(10);\\n\\tdefault_func_b(20);\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -fvisibility=hidden -o default_static default_static.c\\n\\ndefault_static.c:9:1: warning: \u2018visibility\u2019 attribute ignored [-Wattributes]\\n    9 | static void default_func_b(int value) {\\n      | ^~~~~~\\n\\n$ readelf --syms default_static | grep func\\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n    37: 0000000000001171    40 FUNC    LOCAL  DEFAULT   16 default_func_b\\n    63: 0000000000001149    40 FUNC    GLOBAL DEFAULT   16 default_func_a\\n```\\n***\\n<mark>hidden</mark> hides symbols from the outside by not displaying them in the `dynamic symbol table`. That is, the <mark>Symbol Binding</mark> type is set to <mark>STB_LOCAL</mark>.\\n```c\\n: hidden - hidden.c\\n#include <stdio.h>\\n\\n__attribute__((visibility(\\"hidden\\")))\\nvoid hidden_func(int value) {\\n\\tprintf(\\"value: %d\\\\n\\", value);\\n}\\n\\nvoid default_func(int value) {\\n\\tprintf(\\"value: %d\\\\n\\", value);\\n}\\n\\nint main(void) {\\n\\thidden_func(10);\\n\\tdefault_func(20);\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o hidden hidden.c\\n\\n$ readelf --syms hidden | grep func\\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n    49: 0000000000001171    40 FUNC    GLOBAL DEFAULT   16 default_func\\n    55: 0000000000001149    40 FUNC    GLOBAL HIDDEN    16 hidden_func\\n```\\nBut is it really impossible to access a symbol that is set to hidden?\\n```c\\n: hidden access\\n#include <stdio.h>\\n\\n__attribute__((visibility(\\"hidden\\")))\\nvoid hidden_func(int value) {\\n\\tprintf(\\"hidden value: %d\\\\n\\", value);\\n}\\n\\nvoid default_func(int value) {\\n\\tprintf(\\"value: %d\\\\n\\", value);\\n}\\n```\\n```bash\\n: build to shared library\\n$ gcc -shared -fpic -o libhidden.so hidden_library.c \\n```\\n```c\\n: access hidden symbol in library\\nextern void hidden_func(int value);\\nextern void default_func(int value);\\n\\nint main(void) {\\n\\thidden_func(10);\\n\\tdefault_func(20);\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: build test\\n$ gcc -o hidden_access hidden_access.c -L`pwd` -lhidden\\n\\n/usr/bin/ld: /tmp/ccK9AqUL.o: in function `main\':\\nhidden_access.c:(.text+0xe): undefined reference to `hidden_func\'\\ncollect2: error: ld returned 1 exit status\\n```\\nThe linker throws an `error` because `hidden_func` does not exist in the <mark>symbol table</mark>.\\n\\nHowever, it is possible to call using the address and offset of other symbols in the library.\\nGet the function address of the public `default_func` and the function address of `hidden_func` and check the offset difference.\\n\\nYou can use gdb or readelf to check the address.\\nLet\'s use gdb\\n\\n```bash\\n: hidden access - get symbol offset\\n$ gdb libhidden.so\\n\\n(gdb) p default_func \\n$1 = {<text variable, no debug info>} 0x1141 <default_func>\\n(gdb) p hidden_func\\n$2 = {<text variable, no debug info>} 0x1119 <hidden_func>\\n```\\nAn offset difference of 0x28 occurs. Let\'s access `hidden_func` using offset.\\n```c\\n: hidden - access use offset\\nvoid (*hidden_func) (int);\\nextern void default_func(int value);\\n\\nint main(void) {\\n\\thidden_func = default_func - 0x28;\\n\\thidden_func(10);\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -g -o hidden_access hidden_access.c -L`pwd` -lhidden\\n\\n$ LD_LIBRARY_PATH=`pwd` ./hidden_access\\nhidden value: 10\\n```\\n<mark>Hidden visibility</mark> only has no information in the `symbol table`, and it was possible to call it using an address.\\n***\\n<mark>internal</mark> works as <mark>hidden</mark> by default. However, it is said that machine dependency behavior can be added.\\nIt means that more powerful actions may be possible than <mark>hidden</mark>.For example, it is said that access using function pointers can also be blocked. But in gcc, it seems to behave the same as <mark>hidden</mark>. Although the Intel compiler can prevent access using function pointers, I haven\'t been able to test it due to an environmental problem.\\n```c\\n: internal test - internal_library.c\\n#include <stdio.h>\\n\\n__attribute__((visibility(\\"internal\\")))\\nvoid internal_func(int value) {\\n\\tprintf(\\"internal value: %d\\\\n\\", value);\\n}\\n\\nvoid default_func(int value) {\\n\\tprintf(\\"value: %d\\\\n\\", value);\\n}\\n```\\n```bash\\n: check symbol table\\n$ gcc -shared -fPIC -o libinternal.so internal_library.c\\n\\n$ readelf --syms libinternal.so | grep func\\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n    39: 0000000000001119    40 FUNC    LOCAL  DEFAULT   14 internal_func\\n    48: 0000000000001141    40 FUNC    GLOBAL DEFAULT   14 default_func\\n```\\nYes, In gcc, <mark>internal</mark> works as <mark>STB_LOCAL</mark> by default.\\n***\\n<mark>protected</mark> operates <mark>STB_GLOBAL</mark> by default.\\nHowever, it can be used to avoid <mark>symbol preemption (symbol interposing)</mark>.\\n\\nLet\'s say there are two libraries with the `same function name` as follows.\\n```c\\n: symbol preemption case\\n// libfooa.c\\n#include <stdio.h>\\n\\nvoid _foo(int value) {\\n\\tprintf(\\"libfooa - foo: %d\\\\n\\", value);\\n}\\n\\nvoid fooa(int value) {\\n\\t_foo(value);\\n}\\n// libfoob.c \\n#include <stdio.h>\\n\\nvoid _foo(int value) {\\n\\tprintf(\\"libfoob - foo: %d\\\\n\\", value);\\n}\\n\\nvoid foob(int value) {\\n\\t_foo(value);\\n}\\n```\\n```bash\\n: compile as library\\ngcc -shared -fPIC -o libfooa.so libfooa.c\\ngcc -shared -fPIC -o libfoob.so libfoob.c\\n```\\n\\nAnd a function using `fooa`, `foob` and something like this:\\n```c\\n: symbol preemption case - use_foo.c\\nextern void fooa(int value);\\nextern void foob(int value);\\n\\nint main(void) {\\n\\tfooa(10);\\n\\tfoob(10);\\n\\n\\treturn 0;\\n}\\n```\\nRunning after build gives unexpected results.\\n```bash\\n: result\\n$ gcc -o use_foo use_foo.c -L`pwd` -lfooa -lfoob\\n\\n$ LD_LIBRARY_PATH=`pwd` ./use_foo\\nlibfooa - foo: 10\\nlibfooa - foo: 10\\n```\\nThe `foob` function calls _foo of `libfooa.so`, not _foo of `foob`.\\nThis result is related to the `linking order`.\\nIf you change the order as follows, the function `fooa` will call _foo in `libfoob.so`.\\n```bash\\n: Change the linking order\\n$ gcc -o use_foo use_foo.c -L`pwd` -lfoob -lfooa\\n$ LD_LIBRARY_PATH=`pwd` ./use_foo\\n\\nlibfoob - foo: 10\\nlibfoob - foo: 10\\n```\\nThat is, the symbol loaded first by the linker will have higher priority. This means that the symbol can also be changed by <mark>LD_PRELOAD</mark>.\\nThis is why we declare functions as <mark>static</mark> whenever possible.\\n<mark>Protected</mark> exists to use when `static` declaration is not possible.\\n\\nIn the sample below, changing `_foo` to <mark>protected</mark> would result in:\\n```c\\n: Use protected visibility\\n// libfooa.c\\n#include <stdio.h>\\n\\n__attribute__((visibility(\\"protected\\")))\\nvoid _foo(int value) {\\n\\tprintf(\\"libfooa - foo: %d\\\\n\\", value);\\n}\\n\\nvoid fooa(int value) {\\n\\t_foo(value);\\n}\\n\\n// libfoob.c \\n#include <stdio.h>\\n\\n__attribute__((visibility(\\"protected\\")))\\nvoid _foo(int value) {\\n\\tprintf(\\"libfoob - foo: %d\\\\n\\", value);\\n}\\n\\nvoid foob(int value) {\\n\\t_foo(value);\\n}\\n```\\n```bash\\n: result\\n$ gcc -shared -fPIC -o libfooa.so libfooa.c\\n$ gcc -shared -fPIC -o libfoob.so libfoob.c\\n\\n$ LD_LIBRARY_PATH=`pwd` ./use_foo\\nlibfooa - foo: 10\\nlibfoob - foo: 10\\n```\\nEach `_foo` will be called as intended.\\n```bash\\n: symbol check\\nreadelf --syms ./libfooa.so  | grep foo\\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n     6: 0000000000001119    40 FUNC    GLOBAL PROTECTED   14 _foo\\n     7: 0000000000001141    28 FUNC    GLOBAL DEFAULT   14 fooa\\n```\\n\\nFinally, let\'s check how ELF\'s <mark>Symbol Binding</mark> and <mark>Symbol Visibility</mark>are set according to <mark>static</mark> and <mark>visibility attributes</mark>.\\n```c\\n: conclusion - conc.c\\nvoid func() {}\\n\\nstatic void func_static() {}\\n\\n__attribute__((visibility(\\"default\\")))\\nvoid func_default() {}\\n\\n__attribute__((visibility(\\"hidden\\")))\\nvoid func_hidden() {}\\n\\n__attribute__((visibility(\\"internal\\")))\\nvoid func_internal() {}\\n\\n__attribute__((visibility(\\"protected\\")))\\nvoid func_protected() {}\\n\\nint main(void) {\\n\\tfunc();\\n\\tfunc_static();\\n\\tfunc_default();\\n\\tfunc_hidden();\\n\\tfunc_internal();\\n\\tfunc_protected();\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o conc conc.c\\n\\nreadelf --syms ./conc | grep func\\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n    35: 0000000000001134    11 FUNC    LOCAL  DEFAULT   14 func_static\\n    39: 0000000000001155    11 FUNC    LOCAL  DEFAULT   14 func_internal\\n    41: 000000000000114a    11 FUNC    LOCAL  DEFAULT   14 func_hidden\\n    48: 000000000000113f    11 FUNC    GLOBAL DEFAULT   14 func_default\\n    53: 0000000000001160    11 FUNC    GLOBAL PROTECTED   14 func_protected\\n    59: 0000000000001129    11 FUNC    GLOBAL DEFAULT   14 func\\n```\\nIn my personal opinion, when writing library code, by default, <mark>hiding all symbols</mark> using <mark>-fvisibility=hidden</mark> and revealing only libraries that need to be disclosed using <mark>default attribute</mark> is a simple way to reduce mistakes.\\n> Build with `-fvisibility=hidden` and set the symbols that need to be made public to `default attribute`)\\n***\\n\\nFor reference, there is also a way to restrict symbols using the <mark>linker version script</mark>.\\n```c\\n: use linker version script\\n// libbar.c\\nvoid bar_hidden() {}\\nvoid bar() {}\\n\\n//libbar.map\\n{\\n\\tglobal: bar;\\n\\tlocal: *;\\n};\\n```\\n```bash\\n: Build with linker version script\\n$ gcc -shared -fPIC -Wl,--version-script,libbar.map -o libbar.so libbar.c\\n\\n$ readelf --syms libbar.so | grep bar\\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n    38: 00000000000010f9    11 FUNC    LOCAL  DEFAULT   10 bar_hidden\\n    45: 0000000000001104    11 FUNC    GLOBAL DEFAULT   10 bar\\n```\\nHowever, using gcc\'s <mark>visibility attribute</mark> is more `advantageous` in terms of `optimization` such as not creating unnecessary <mark>program lookup table (PLT)</mark>, so it is recommended to use the gcc <mark>visibility attribute</mark> instead of using the linker script."}')}}]);