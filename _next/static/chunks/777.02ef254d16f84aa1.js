"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[777],{8777:function(n){n.exports=JSON.parse('{"content":"\\n\\n#### Requires\\n: compiler : gcc 2.8 later\\n: glibc : 2.2 later\\n***\\n\\nWhen using glibc functions that use format like printf, you may have often seen that a `compile warning` occurs if you use the wrong format.\\n\\n```c\\n: If format is used incorrectly, a compile warning occurs.\\n$ cat ./format_warning.c\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tprintf(\\"%d, %d\\\\n\\", (int)1, (unsigned long)2);\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n$ gcc -o format_warning format_warning.c\\nformat_warning.c: In function \u2018main\u2019:\\nformat_warning.c:4:15: warning: format \u2018%d\u2019 expects argument \\\\\\n  of type \u2018int\u2019, but argument 3 has type \u2018long unsigned int\u2019 [-Wformat=]\\n  printf(\\"%d, %d\\\\n\\", (int)1, (unsigned long)2);\\n              ~^             ~~~~~~~~~~~~~~~~\\n```\\n\\nThe compiler kindly informs why you use to print `unsigned long` as `%d`.\\n\\nNot only the argument type but also the situation where the number of arguments is incorrect is displayed as a warning.\\n\\n```c\\n: Even if the number of arguments is incorrectly set.\\n$ cat ./format_warning2.c\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tprintf(\\"%d, %d\\\\n\\", 1);\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n$ gcc -o format_warning2 format_warning2.c\\nformat_warning2.c: In function \u2018main\u2019:\\nformat_warning2.c:4:15: warning: format \u2018%d\u2019 expects a matching \u2018int\u2019 argument [-Wformat=]\\n    printf(\\"%d, %d\\\\n\\", 1);\\n```\\nFor <mark>-Wformat</mark>, let\'s look at the gcc documentation first.\\n\\n> #### gcc-7.5.0/Warning-Options\\n> <b>-Wformat</b>\\n> <b>-Wformat=n</b><br>\\n> Check calls to <b>printf</b> and <b>scanf</b>, etc.,<br>\\nto make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.<br> This includes <b>standard functions</b>, and <b>others specified by format attributes</b> (see Function Attributes),<br> in the printf, scanf, strftime and strfmon (an X/Open extension, not in the C standard) families (or other target-specific families).<br> Which functions are checked without format attributes having been specified depends on the standard version selected, and such checks of functions without the attribute specified are disabled by -ffreestanding or -fno-builtin.<br>\\n> The formats are checked against the format features supported by <b>GNU libc version 2.2</b>.<br> These include all ISO C90 and C99 features, as well as features from the Single Unix Specification and some BSD and GNU extensions.<br>Other library implementations may not support all these features; GCC does not support warning about features that go beyond a particular library\u2019s limitations.<br> However, if <b>-Wpedantic</b> is used with <b>-Wformat</b>, warnings are given about format features not in the selected standard version (but not for strfmon formats, since those are not in any version of the C standard).<br>\\n> **ref:&nbsp;**<a target=\\"_blank\\" href=\\"https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Warning-Options.html#Warning-Options\\"><code>https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Warning-Options.html#Warning-Options</code></a></cite>\\n\\nIt is stated that some standard functions after glibc 2.2 are supported.\\n\\nSo which functions in glibc support <mark>-Wformat</mark>?\\nIf you look at the gcc code, you can see the list of supported functions.\\n\\n```c\\n: git checkout releases/gcc-3.0\\n$ cat ./gcc/c-format.c\\n...\\nvoid\\ninit_function_format_info ()\\n{\\n  if (flag_hosted)\\n    {\\n      /* Functions from ISO/IEC 9899:1990.  */\\n      record_function_format (get_identifier (\\"printf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 1, 2);\\n      record_function_format (get_identifier (\\"__builtin_printf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 1, 2);\\n      record_function_format (get_identifier (\\"fprintf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 2, 3);\\n      record_function_format (get_identifier (\\"__builtin_fprintf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 2, 3);\\n      record_function_format (get_identifier (\\"sprintf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 2, 3);\\n      record_function_format (get_identifier (\\"scanf\\"), NULL_TREE,\\n\\t\\t\\t      scanf_format_type, 1, 2);\\n      record_function_format (get_identifier (\\"fscanf\\"), NULL_TREE,\\n\\t\\t\\t      scanf_format_type, 2, 3);\\n      record_function_format (get_identifier (\\"sscanf\\"), NULL_TREE,\\n\\t\\t\\t      scanf_format_type, 2, 3);\\n      record_function_format (get_identifier (\\"vprintf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 1, 0);\\n      record_function_format (get_identifier (\\"vfprintf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 2, 0);\\n      record_function_format (get_identifier (\\"vsprintf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 2, 0);\\n      record_function_format (get_identifier (\\"strftime\\"), NULL_TREE,\\n\\t\\t\\t      strftime_format_type, 3, 0);\\n    }\\n\\n  if (flag_hosted && flag_isoc99)\\n    {\\n      /* ISO C99 adds the snprintf and vscanf family functions.  */\\n      record_function_format (get_identifier (\\"snprintf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 3, 4);\\n      record_function_format (get_identifier (\\"vsnprintf\\"), NULL_TREE,\\n\\t\\t\\t      printf_format_type, 3, 0);\\n      record_function_format (get_identifier (\\"vscanf\\"), NULL_TREE,\\n\\t\\t\\t      scanf_format_type, 1, 0);\\n      record_function_format (get_identifier (\\"vfscanf\\"), NULL_TREE,\\n\\t\\t\\t      scanf_format_type, 2, 0);\\n      record_function_format (get_identifier (\\"vsscanf\\"), NULL_TREE,\\n\\t\\t\\t      scanf_format_type, 2, 0);\\n    }\\n  ...\\n```\\n\\nThe gcc code is too complex to understand in detail, but it seems to be broadly classified into `printf`, `scanf`, and `strftime`.\\n\\nThen, isn\'t there a way to add your own function defined using `va_arg()` instead of the glibc standard function as a detection target for <mark>-Wformat</mark>?\\n\\nYou can use <mark>__attribute__((format))</mark> as mentioned in the above document.\\n\\n`__attribute__((format))` will be discussed in detail in another post.\\n> Actually, I want to introduce `__attribute__((format))`, so I am explaining `-Wformat` first.\\n\\nThere are many kinds of options of the <mark>-Wformat</mark> type. Let\'s check these briefly.\\n\\nLet\'s take a look at gcc-7.5.0.\\n***\\n#### -Wformat-contains-nul\\nChecks whether format contains a NUL string (\'\\\\0\').\\n```c\\n: sample source code - format_contains_nul.c\\n#include <stdio.h>\\n\\nint main(void) {\\n    char buf[16];\\n    sprintf(buf, \\"%s\\\\0\\", \\"test\\");\\n\\n    return 0;\\n}\\n```\\n```bash\\n: compile\\n$ gcc -o format_contains_nul format_contains_nul.c -Wformat-contains-nul\\n```\\n```bash\\n: output\\nformat_contains_nul.c: In function \u2018main\u2019:\\nformat_contains_nul.c:5:21: warning: embedded \u2018\\\\0\u2019 in format [-Wformat-contains-nul]\\n    5 |     sprintf(buf, \\"%s\\\\0\\", \\"test\\");\\n      |                     ^~\\n```\\n***\\n#### -Wformat-extra-args\\nCheck if there are more arguments than format specifiers.\\n```c\\n: sample source code - format_extra_args.c\\n#include <stdio.h>\\n\\nint main(void) {\\n    printf(\\"excess arguments: %s\\", __LINE__, \\"what\\");\\n\\n    return 0;\\n}\\n```\\n```bash\\n: compile\\n$ gcc -o format_extra_args format_extra_args.c -Wformat-extra-args\\n```\\n```bash\\n: output\\nformat_extra_args.c: In function \u2018main\u2019:\\n...\\nformat_extra_args.c:4:12: warning: too many arguments for format [-Wformat-extra-args]\\n    4 |     printf(\\"excess arguments: %s\\", __LINE__, \\"what\\");\\n```\\n***\\n#### -Wformat-overflow\\nWhen writing to the destination buffer according to the format like `sprintf` or `vsprintf`, A value larger than the buffer size is entered and it is checked whether overflow occurs.\\n```c\\n: sample source code - format_overflow.c\\n#include <stdio.h>\\n\\nint main(void) {\\n    char buf[10];\\n    sprintf(buf, \\"overflow %s\\", \\"ho!\\");\\n\\n    return 0;\\n}\\n```\\n```bash\\n: compile\\n$ gcc -o format_overflow format_overflow.c -Wformat-overflow\\n```\\n```bash\\n: output\\nformat_overflow.c: In function \u2018main\u2019:\\nformat_overflow.c:5:28: warning: \u2018%s\u2019 directive writing 3 bytes into a region of size 1 [-Wformat-overflow=]\\n    5 |     sprintf(buf, \\"overflow %s\\", \\"ho!\\");\\n      |                            ^~   ~~~~~\\nformat_overflow.c:5:5: note: \u2018sprintf\u2019 output 13 bytes into a destination of size 10\\n    5 |     sprintf(buf, \\"overflow %s\\", \\"ho!\\");\\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n```\\n\\nWhat happens if it\'s hard to predict in a compile time?\\n```c\\n: sample source code - format_overflow.c\\n#include <stdio.h>\\n\\nint main(int argc, const char *argv[]) {\\n    char buf[10];\\n    sprintf(buf, \\"overflow %s\\", argv[0]);\\n\\n    return 0;\\n}\\n```\\n```bash\\n: compile\\n$ gcc -o format_overflow format_overflow.c -Wformat-overflow\\n```\\n```c\\n: output\\n...\\n```\\nIn fact, regardless of the argv value, the code already causes a buffer overflow by format, but `-Wformat-overflow` is not detecting overflow.\\nIn this case, you can specify the level of <mark>Wformat-overflow</mark>.\\n```bash\\n: compile with -Wformat-overflow=2\\n$  gcc -o format_overflow format_overflow.c -Wformat-overflow=2\\n```\\n```bash\\n: output\\nformat_overflow.c: In function \u2018main\u2019:\\nformat_overflow.c:5:30: warning: \u2018sprintf\u2019 may write a terminating nul past the end of the destination [-Wformat-overflow=]\\n    5 |     sprintf(buf, \\"overflow %s\\", argv[0]);\\n      |                              ^\\nformat_overflow.c:5:5: note: \u2018sprintf\u2019 output 10 or more bytes (assuming 11) into a destination of size 10\\n    5 |     sprintf(buf, \\"overflow %s\\", argv[0]);\\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n```\\n***\\n#### -Wformat-zero-length\\nCheck if format is zero length.\\n```c\\n: sample source code - format_zero_length.c\\n#include <stdio.h>\\n\\nint main(void) {\\n    printf(\\"\\",\\"zero-length\\");\\n    return 0;\\n}\\n```\\n```bash\\n: compile\\n$ gcc -o format_zero_length format_zero_length.c -Wformat-zero-length\\n```\\n```bash\\n: output\\nformat_zero_length.c: In function \u2018main\u2019:\\nformat_zero_length.c:4:12: warning: zero-length gnu_printf format string [-Wformat-zero-length]\\n    4 |     printf(\\"\\",\\"zero-length\\");\\n      |            ^~\\n```\\nIn fact, such code cannot be written, right? However, this code happens surprisingly often.\\n```c\\n    const char fmt[] = \\"\\";\\n    printf(fmt,\\"zero-length\\");\\n```\\n***\\n#### -Wformat-nonliteral\\nChecks if format is a string literal.\\n```c\\n: sample source code - format_nonliteral.c\\n#include <stdio.h>\\n\\nint main(void) {\\n    char fmt[] = \\"%s\\";\\n    printf(fmt,\\"test\\");\\n\\n    return 0;\\n}\\n```\\n```bash\\n: compile\\n$ gcc -o format_nonliteral format_nonliteral.c -Wformat-nonliteral\\n```\\n```bash\\n: output\\nformat_nonliteral.c: In function \u2018main\u2019:\\nformat_nonliteral.c:5:12: warning: format not a string literal, argument types not checked [-Wformat-nonliteral]\\n    5 |     printf(fmt,\\"test\\");\\n      |            ^~~\\n```\\nIf fmt is specified as const char, this warning disappears.\\n```diff\\n- char fmt[] = \\"%s\\";\\n+ const char fmt[] = \\"%s\\";\\n```\\nHowever, sometimes you need to write code that needs to dynamically change fmt.\\n```c\\n#include <stdio.h>\\n\\nchar* get_format(int value) {\\n    if (value == 1)\\n        return \\"%d\\";\\n    else\\n        return \\"%s\\";\\n}\\n\\nint main(void) {\\n    printf(get_format(1),\\"test\\");\\n\\n    return 0;\\n}\\n```\\nSo, sometimes we add code that ignores this option.\\n```c\\n#pragma GCC diagnostic ignored \\"-Wformat-nonliteral\\"\\n...\\n#pragma GCC diagnostic warning \\"-Wformat-nonliteral\\"\\n```\\n***\\n#### -Wformat-security\\nDetects when format is not string internal and there is no argument.\\n```c\\n: sample source code - format_security.c\\n#include <stdio.h>\\n\\nint main(void) {\\n    char *fmt = \\"%s\\";\\n    printf(fmt);\\n\\n    return 0;\\n}\\n```\\n```bash\\n: compile\\n$ gcc -o format_security format_security.c -Wformat-security\\n```\\n```bash\\n: output\\nformat_security.c: In function \u2018main\u2019:\\nformat_security.c:5:5: warning: format not a string literal and no format arguments [-Wformat-security]\\n    5 |     printf(fmt);\\n      |     ^~~~~~\\n```\\nWhat causes this to be detected? There\'s a reason the option name is security.\\n\\nIf it is a non-iternal string, the format can be changed to `%n`, and since the arugment can be manipulated through stack overflow, etc., it becomes a code capable of `Format String Bug Exploration`.\\n\\nThat is, the code with the security hole.\\n\\nI plan to deal with `Format String Bug Exploration` in a post if I get a chance.\\n***\\n#### -Wformat-signedness\\nAs the name suggests, when format is signed but argument is used as unsigned, or vice versa.\\n```c\\n: sample source code - format_signedness\\n#include <stdio.h>\\n\\nint main(void) {\\n    unsigned int a = 10;\\n    signed int b = -10;\\n\\n    printf(\\"%d %u\\", a, b);\\n\\n    return 0;\\n}\\n```\\n```bash\\n: compile\\n$ gcc -o format_signedness format_signedness.c -Wformat-signedness\\n```\\n```bash\\n: output\\nformat_signedness.c: In function \u2018main\u2019:\\nformat_signedness.c:7:14: warning: format \u2018%d\u2019 expects argument of type \u2018int\u2019, but argument 2 has type \u2018unsigned int\u2019 [-Wformat=]\\n    7 |     printf(\\"%d %u\\", a, b);\\n      |             ~^      ~\\n      |              |      |\\n      |              int    unsigned int\\n      |             %d\\nformat_signedness.c:7:17: warning: format \u2018%u\u2019 expects argument of type \u2018unsigned int\u2019, but argument 3 has type \u2018int\u2019 [-Wformat=]\\n    7 |     printf(\\"%d %u\\", a, b);\\n      |                ~^      ~\\n      |                 |      |\\n      |                 |      int\\n      |                 unsigned int\\n      |                %u\\n```\\n***\\n#### -Wformat-truncation\\nIt detects and warns that the result is truncated by a function that specifies length, such as snprintf.\\n```c\\n: sample source code - format_truncation\\n#include <stdio.h>\\n\\nint main(void) {\\n    char buf[10];\\n    snprintf(buf, sizeof(buf), \\"%s\\", \\"string truncation\\");\\n\\n    return 0;\\n}\\n```\\n```bash\\n: compile\\n$ gcc -o format_truncation format_truncation.c -Wformat-truncation\\n```\\n```bash\\n: output\\nformat_truncation.c: In function \u2018main\u2019:\\nformat_truncation.c:5:33: warning: \u2018%s\u2019 directive output truncated writing 17 bytes into a region of size 10 [-Wformat-truncation=]\\n    5 |     snprintf(buf, sizeof(buf), \\"%s\\", \\"string truncation\\");\\n      |                                 ^~   ~~~~~~~~~~~~~~~~~~~\\nformat_truncation.c:5:5: note: \u2018snprintf\u2019 output 18 bytes into a destination of size 10\\n    5 |     snprintf(buf, sizeof(buf), \\"%s\\", \\"string truncation\\");\\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n```\\n***\\nThe above problems may seem trivial, but depending on the situation, a stack overflow may occur at runtime, and it may become a security hole.\\n\\nAs the project grows, it can be a great advantage to be able to recognize these issues at compile time and fix them in advance.\\n\\nTherefore, it is recommended to add <mark>-Wformat</mark> or <mark>-Werror=format</mark> to the compile option as much as possible."}')}}]);