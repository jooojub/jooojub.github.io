"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[292],{7292:function(n){n.exports=JSON.parse('{"content":"\\n\\n#### Requires\\n: compiler : gcc 3.1 later\\n***\\n\\nIn a previous post, we learned about the builtin function called <mark>__builtin_choose_expr</mark>.\\nIn that post, I implemented `function overloading` according to the `argument type` using <mark>__builtin_types_compatible_p</mark> in C.\\n\\nLet\'s see what <mark>__builtin_types_compatible_p</mark> is `builtin` for.\\n```c\\n: usage - sample.c\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(char, char));\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(int, char));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result - usage\\n$ gcc -g -o sample sample.c\\n\\n$ ./sample\\n1\\n0\\n```\\nChecks if two types are equal, returns `1 if they are equal`, and `0 otherwise`.\\n\\nIn fact, it is rare to use both arguments with types as above.\\nIn general, it is used together with `typeof keyword`.\\n```c\\n: usage - sample_typeof.c\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tchar a;\\n\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(typeof(a), char));\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(typeof(a), int));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result - sample_typeof\\n$ gcc -g -o sample_typeof sample_typeof.c\\n\\n$ ./sample_typeof\\n1\\n0\\n```\\nA `builtin` is a function used by gcc at <mark>build-time</mark>, not run-time.\\nLet\'s disassemble the sample.\\n```x86asm\\n: disassemble - sample\\n$ objdump -S sample\\n\\nint main(void) {\\n    1149:\\tf3 0f 1e fa          \\tendbr64 \\n    114d:\\t55                   \\tpush   %rbp\\n    114e:\\t48 89 e5             \\tmov    %rsp,%rbp\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(char, char));\\n    // The result calculated by gcc goes into the code\\n    1151:\\tbe 01 00 00 00       \\tmov    $0x1,%esi\\n    1156:\\t48 8d 3d a7 0e 00 00 \\tlea    0xea7(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>\\n    115d:\\tb8 00 00 00 00       \\tmov    $0x0,%eax\\n    1162:\\te8 e9 fe ff ff       \\tcallq  1050 <printf@plt>\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(int, char));\\n    // The result calculated by gcc goes into the code\\n    1167:\\tbe 00 00 00 00       \\tmov    $0x0,%esi\\n    116c:\\t48 8d 3d 91 0e 00 00 \\tlea    0xe91(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>\\n    1173:\\tb8 00 00 00 00       \\tmov    $0x0,%eax\\n    1178:\\te8 d3 fe ff ff       \\tcallq  1050 <printf@plt>\\n```\\nI tested it by entering various values.\\n***\\n```c\\n: test - int == signed int\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(int, signed int));\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(int, unsigned int));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c\\n$ ./test\\n1\\n0\\n```\\n`int` is `signed int` by default.\\n***\\n```c\\n: test - char != unsigned char | signed char\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(char, signed char));\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(char, unsigned char));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c -fsigned-char\\n$ ./test\\n0\\n0\\n\\n$ gcc -o test test.c -funsigned-char\\n$ ./test\\n0\\n0\\n```\\n\\n\\nIn a previous post, I said that the default type of `char` can be determined through the <mark>-fsigned-char</mark> or <mark>-funsigned-char</mark> gcc option.\\nHowever, the result is different than expected, no matter what option is given, the result is different.\\nI have to be careful when using it.\\n***\\n```c\\n: test - size_t == unsigned long == unsigned long int\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(size_t, unsigned long));\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(size_t, unsigned long int));\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(unsigned long, unsigned long int));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c\\n$ ./test\\n1\\n1\\n1\\n```\\n`size_t` is defined as `unsigned long int` as typedef in `stddef.h`. This is equivalent to an `unsigned long`.\\n```c\\n: stddef.h\\n#define __SIZE_TYPE__ long unsigned int\\n...\\ntypedef __SIZE_TYPE__ size_t;\\n```\\n***\\n```c\\n: test - char [] != char *\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(char *, char []));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c\\n$ ./test\\n0\\n```\\n***\\n```c\\n: test - char * != char **\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(char *, char **));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c\\n$ ./test\\n0\\n```\\n***\\n```c\\n: test - const char == char\\n#include <stdio.h>\\n\\nint main(void) {\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(const char, char));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c\\n$ ./test\\n1\\n```\\n<mark>__builtin_types_compatible_p</mark> ignores top level qualifiers such as const or volatile.\\nThis does not mean that the two types are exactly the same. Be careful.\\n***\\n```c\\n: test - struct\\n#include <stdio.h>\\n\\nstruct test{\\n\\tint val;\\n};\\n\\nint main(void) {\\n\\tstruct test d;\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(typeof(d), struct test));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c\\n$ ./test\\n1\\n```\\nOf course you can use struct member variables as well.\\n```c\\n: test - struct member\\n#include <stdio.h>\\n\\nstruct test{\\n\\tint val;\\n};\\n\\nint main(void) {\\n\\tstruct test d;\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(typeof(d.val), int));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c\\n$ ./test\\n1\\n```\\n***\\n```c\\n: test - typedef\\n#include <stdio.h>\\n\\ntypedef int myint;\\n\\nint main(void) {\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(int, myint));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c\\n$ ./test\\n1\\n```\\nAs we saw with `size_t`, a `typedef` is also possible.\\n***\\n```c\\n: test - enum a != enum b\\n#include <stdio.h>\\n\\nenum A {\\n\\tAAA = 0,\\n};\\n\\nenum B {\\n\\tBBB = 0,\\n};\\n\\nint main(void) {\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(enum A, enum B));\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(typeof(AAA), int));\\n\\tprintf(\\"%d\\\\n\\", __builtin_types_compatible_p(typeof(AAA), typeof(BBB)));\\n\\n\\treturn 0;\\n}\\n```\\n```bash\\n: result\\n$ gcc -o test test.c\\n$ ./test\\n0\\n1\\n1\\n```\\n`enum` is also recognized as different types. And `members of enum` is treated as `int`.\\n***\\nLet\'s see how we can use this `builtin`.\\nIt is common to use `builtin` with `macro`.\\n\\nIt can be implemented similarly to `function overloading` in c.\\n```c\\n: how to use - like function overloading\\n#define bar(x)\\n({  \\\\\\n\\ttypeof (x) tmp = (x); \\\\\\n\\tif (__builtin_types_compatible_p (typeof(x), double))\\t\\\\\\n\\t\\ttmp = function_double(tmp); \\\\\\n\\telse if (__builtin_types_compatible_p (typeof(x), int))\\t\\\\\\n\\t\\ttmp = function_int(tmp);  \\\\\\n\\telse  \\\\\\n\\t\\tbug();  \\\\\\n\\ttmp;  \\\\\\n})  \\\\\\n```\\nA more advanced implementation is possible by using <mark>__builtin_choose_expr</mark>.\\n```c\\n: how to use - like function overloading2\\n#define debug(var) \\\\\\n  printf( \\\\\\n    __builtin_choose_expr(  \\\\\\n      __builtin_types_compatible_p(typeof(var), int)  \\\\\\n        ,\\"%d\\\\n\\", __builtin_choose_expr( \\\\\\n      __builtin_types_compatible_p(typeof(var), char [])  \\\\\\n        ,\\"%s\\\\n\\", \\"0x%x\\\\n\\")), var);\\n```\\nIt is also used for type checking in systemd code.\\n```c\\n: cat ./src/fundamental/macro-fundamental.h\\n#define IS_UNSIGNED_INTEGER_TYPE(type) \\\\\\n        (__builtin_types_compatible_p(typeof(type), unsigned char) ||   \\\\\\n         __builtin_types_compatible_p(typeof(type), unsigned short) ||  \\\\\\n         __builtin_types_compatible_p(typeof(type), unsigned) ||        \\\\\\n         __builtin_types_compatible_p(typeof(type), unsigned long) ||   \\\\\\n         __builtin_types_compatible_p(typeof(type), unsigned long long))\\n\\n#define IS_SIGNED_INTEGER_TYPE(type) \\\\\\n        (__builtin_types_compatible_p(typeof(type), signed char) ||   \\\\\\n         __builtin_types_compatible_p(typeof(type), signed short) ||  \\\\\\n         __builtin_types_compatible_p(typeof(type), signed) ||        \\\\\\n         __builtin_types_compatible_p(typeof(type), signed long) ||   \\\\\\n         __builtin_types_compatible_p(typeof(type), signed long long))\\n```\\nBesides, it is widely used.\\nSince builtin functions are calculated at `compile time`, they have the advantage of no runtime overhead, so it is recommended to use them together with `macro` in a way that does not cause readability problems."}')}}]);