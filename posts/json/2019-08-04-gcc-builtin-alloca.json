{
 "content": "\n\n#### Requires\n: compiler: gcc 2.8 later\n***\n\nLet's take a look at <mark>__builtin_alloca</mark>, one of the gcc builtins.\n\nThe first thing to keep in mind is that many books and posts advise against using <mark>alloca</mark> built-in' from a `security standpoint`.\n\nI hope that through this post, you can clearly understand why.\n\nIf you've looked at open-source code a lot, you'll often see <mark>__builtin_alloca</mark>.\n\nFor example, glibc's `strdupa` macro is defined as follows:\n\n```c\n: strdupa macro (glibc/string/string.h)\n# define strdupa(s)\t\t\t\t\t\t\t   \t\t\t\\\n  (__extension__\t\t\t\t\t\t\t     \t\t\\\n    ({\t\t\t\t\t\t\t\t\t      \t\t\t\\\n      const char *__old = (s);\t\t\t\t\t\t\t\\\n      size_t __len = strlen (__old) + 1;\t\t\t\t\\\n      char *__new = (char *) __builtin_alloca (__len);\t\\\n      (char *) memcpy (__new, __old, __len);\t\t\t\\\n    }))\n```\n\n<mark>__builtin_alloca</mark> is a gcc built-in function that can be set to be allocated on the `stack` instead of the `heap` when allocating dynamic variables.\n\nSo if you look at glibc's `strdupa` code, you can see that it doesn't call free().\n\nSince it is not allocated on the heap like malloc(), its life-time becomes a `function block`.\n\nTherefore, as with any local variable, without a separate free(), the effect of freeing can be exerted only by restoring the stack pointer to the caller function.\n\nAs a result, both `cpu-time` and `memory` have advantages over malloc.\n\n<mark>__builtin_alloca</mark> is a function called by gcc at `compile-time`, not a function called by process at run-time.\nIt works like a macro, but not strictly a macro.\n\nYou can see that <mark>__builtin_alloca</mark> is converted to other code by gcc via disassemble.\n\n```x86asm\n: builtin_alloca was replaced to\nvoid func(size_t n, const char* src) {\n    ...\n\tchar *val = (char *)__builtin_alloca(n);\n 739:\t48 8b 45 e8          \tmov    -0x18(%rbp),%rax\n 73d:\t48 8d 50 0f          \tlea    0xf(%rax),%rdx\n 741:\tb8 10 00 00 00       \tmov    $0x10,%eax\n 746:\t48 83 e8 01          \tsub    $0x1,%rax\n 74a:\t48 01 d0             \tadd    %rdx,%rax\n 74d:\tb9 10 00 00 00       \tmov    $0x10,%ecx\n 752:\tba 00 00 00 00       \tmov    $0x0,%edx\n 757:\t48 f7 f1             \tdiv    %rcx\n 75a:\t48 6b c0 10          \timul   $0x10,%rax,%rax\n 75e:\t48 29 c4             \tsub    %rax,%rsp\n 761:\t48 89 e0             \tmov    %rsp,%rax\n 764:\t48 83 c0 0f          \tadd    $0xf,%rax\n 768:\t48 c1 e8 04          \tshr    $0x4,%rax\n 76c:\t48 c1 e0 04          \tshl    $0x4,%rax\n 770:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)\n\n\tmemcpy(val, src, n);\n\t...\n```\nYou can see that it is not in the form of a function call like `callq __builtin_alloca`\n\nThis builtin allocates a dynamic variable and is used where it is guaranteed to be used temporarily in a function, such as a local variable.\n\nLet's take a look at the gcc documentation.\n\n> #### Built-in Function: void *__builtin_alloca (size_t size)\n> The `__builtin_alloca` function must be called at block scope<br>.\n> The function allocates an object size bytes large on the stack of the calling function. The object is aligned on the default `stack` alignment boundary for the target determined by the __BIGGEST_ALIGNMENT__ macro.<br>\n> The __builtin_alloca function returns a pointer to the first byte of the allocated object.\nThe lifetime of the allocated object ends just before the <b>calling function returns to its caller</b>.<br>\n> This is so even when __builtin_alloca is called within a nested block.<br>\n> **ref:&nbsp;**<a target=\"_blank\" href=\"https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/Other-Builtins.html#Other-Builtins\"><code>https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/Other-Builtins.html#Other-Builtins</code></a></cite>\n\nI haven't looked closely at the gcc code, but it's a builtin that has been around since gcc 2.8.\n\nLet's easily check how to use it through the sample code.\n\n```c\n: sample code - alloca.c\n#include <stdio.h>\n#include <string.h>\n\nvoid func(const size_t n, const char* src) {\n\tchar *val = (char *)__builtin_alloca(n);\n\tstrncpy(val, src, n - 1);\n\tval[n - 1] = '\\0';\n\n\tprintf(\"val: %s\\n\", val);\n}\n\nint main(void) {\n\tfunc(4, \"simple\");\n\n\treturn 0;\n}\n```\n```bash\n: gcc version 7.4.0 --target=x86_64-linux-gnu\n$ gcc -g -o alloca alloca.c\n$ ./alloca\nval: sim\n```\n\n```x86asm\n: assembly - x86_64 AT&T\nvoid func(const size_t n, const char* src) {\n 6fa:\t55                   \tpush   %rbp\n 6fb:\t48 89 e5             \tmov    %rsp,%rbp\n 6fe:\t48 83 ec 20          \tsub    $0x20,%rsp\n 702:\t48 89 7d e8          \tmov    %rdi,-0x18(%rbp)\n 706:\t48 89 75 e0          \tmov    %rsi,-0x20(%rbp)\n 70a:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax\n 711:\t00 00 \n 713:\t48 89 45 f8          \tmov    %rax,-0x8(%rbp)\n 717:\t31 c0                \txor    %eax,%eax\n\tchar *val = (char *)__builtin_alloca(n);\n 719:\t48 8b 45 e8          \tmov    -0x18(%rbp),%rax\n 71d:\t48 8d 50 0f          \tlea    0xf(%rax),%rdx\n 721:\tb8 10 00 00 00       \tmov    $0x10,%eax\n 726:\t48 83 e8 01          \tsub    $0x1,%rax\n 72a:\t48 01 d0             \tadd    %rdx,%rax\n 72d:\tb9 10 00 00 00       \tmov    $0x10,%ecx\n 732:\tba 00 00 00 00       \tmov    $0x0,%edx\n 737:\t48 f7 f1             \tdiv    %rcx\n 73a:\t48 6b c0 10          \timul   $0x10,%rax,%rax\n 73e:\t48 29 c4             \tsub    %rax,%rsp\n 741:\t48 89 e0             \tmov    %rsp,%rax\n 744:\t48 83 c0 0f          \tadd    $0xf,%rax\n 748:\t48 c1 e8 04          \tshr    $0x4,%rax\n 74c:\t48 c1 e0 04          \tshl    $0x4,%rax\n 750:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)\n\tstrncpy(val, src, n);\n ...\n 7a6:\tc9                   \tleaveq \n 7a7:\tc3                   \tretq   \n```\n\nThe align routines were also added by the compiler, but the important part is that the stack size is just increased for variable allocation, and when the function returns, it simply `retq` without free().\n\nThe gcc documentation describes scope as follows:\n> The lifetime of the allocated object ends just before the calling function returns to its caller\n\nIn glibc 1.09, <mark>__builtin_alloca</mark> was defined as <mark>alloca</mark> to shorten the long names.\n\n```c\n: __builtin_alloca is defined as alloca in glibc/stdlib/alloca.h\n#ifdef\t__GNUC__\n# define alloca(size)\t__builtin_alloca (size)\n#endif /* GCC.  */\n```\nSo if you include `alloca.h`, you can simply use `alloca`.\n\nHowever, in my personal opinion, since gcc built-in is not a function called at run-time, but a function called by gcc at compile-time, I think it would be better to express the prefix <mark>__builtin</mark> as it is.\n\nHowever, this is simply a matter of coding style, and if it is a multi-person project, you can make a promise (coding rules) about how to use it and use it.\n\nIt looks like ->[^1]VLA[/^] supported by C99, but the lifetime is different from VLA.\n\n\n\n\n\n\n\n\nVLA의 litftime block scope이고 `alloca`는 function scope입니다.<br>\n즉, 다음과 같은 상황에서는 VLA을 사용할 수 없습니다.\n\n#### -> It is impossible in VLA\n{% highlight c %}\n#define COUNT 10\n\nstruct sample {\n\tunsigned char *p_x;\n};\n\nvoid func(void) {\n\tstruct sample val[COUNT];\n\tint i;\n\n\tfor (i = 0; i < COUNT; i++) {\n\t\t/* Use VLA */\n\t\tunsigned char x[i];\n\t\t/* unsigned char *x = (unsigned char *)__builtin_alloca(i); */\n\t\tmemset(x, 0, i);\n\n\t\tval[i].p_x = x;\n\t\t/* The lifetime of x is terminated */\n\t}\n\n\tsumthing_to_do(val);\n\n\treturn;\n}\n{% endhighlight %}\n\n위에서 언급했던 거처럼, 많은 책과 post에서 stack에 변수를 동적 할당하는 VLA나 alloca는 security 측면에서 un-safe 하기 때문에 사용을 자제하라고 권고하고 있고, 저 또한 동의합니다.<br>\nstack에 변수를 동적 할당하는 코드는 stack overflow를 유발 할 수 있으며 이것이 security hole이 될 수 있습니다.<br>\n또한 length에 nagative number가 사용된다면 전혀 의도하지 않은 방향으로 코드가 흘러갈 수 있습니다.<br>\n그리고 Standard C에서 흔히 동적 할당에 사용되는 alloc/free 짝을 맞춰 코딩하는 방식과는 다르기 때문에 `alloca`를 모르는 사람들에게 혼돈을 줄 수 있습니다.<br>\n-> alloca는 standard가 아닙니다 - GNU extension 입니다...\n\n위와 같은 이유에서, kernel 프로젝트에서는 VLA 코드 제거에 많은 노력을 하였으며 결과적으로 4.20에서 완벽하게 성공하였습니다.\n> ref: https://www.phoronix.com/scan.php?page=news_item&px=Linux-Kills-The-VLA\n\nGNU document에서는 `alloca`의 이점에 대해서 다음과 같이 설명하였습니다:\n\n***\n<table>\n    <thead>\n        <tr>\n            <th>Advantages-of-Alloca</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n\t\t\t\t* Using alloca wastes very <b>little space</b> and is very <b>fast</b>. (It is open-coded by the GNU C compiler.)<br><br>\n                * Since alloca does not have separate pools for different sizes of blocks, space used for any size block can be reused for any other size. alloca <b>does not cause memory fragmentation.</b><br><br>\n                * Nonlocal exits done with longjmp (see Non-Local Exits) automatically free the space allocated with alloca when they exit through the function that called alloca. This is the most important reason to use alloca.\n                <br><br>\n                <cite>ref. <a href=\"https://www.gnu.org/software/libc/manual/html_node/Advantages-of-Alloca.html#Advantages-of-Alloca\"><code>https://www.gnu.org/software/libc/manual/html_node/Advantages-of-Alloca.html#Advantages-of-Alloca</code></a></cite>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n***\n\n또한, 단점은 다음과 같이 설명하였습니다.\n\n***\n<table>\n    <thead>\n        <tr>\n            <th>Disadvantages-of-Alloca</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n\t\t\t\t* If you try to allocate more memory than the machine can provide, you don’t get a clean error message. Instead you get a fatal signal like the one you would get from an infinite recursion; probably a segmentation violation (see Program Error Signals).<br><br>\n                * Some non-GNU systems fail to support alloca, so it is less portable. However, a slower emulation of alloca written in C is available for use on systems with this deficiency.\n                <br><br>\n                <cite>ref. <a href=\"https://www.gnu.org/software/libc/manual/html_node/Disadvantages-of-Alloca.html#Disadvantages-of-Alloca\"><code>https://www.gnu.org/software/libc/manual/html_node/Disadvantages-of-Alloca.html#Disadvantages-of-Alloca</code></a></cite>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n***\n\ngcc 4.7에는 `__builtin_alloca_with_align`가 추가되었으며 gcc 8.1에는 `__builtin_alloca_with_align_and_max`가 추가되었습니다.<br>\n`alloca`를 좀 더 safe하게 사용할 수 있게 max_size 또는 align을 설정할 수 있도록 추가되었습니다.\n\n단순한 추가입니다. 문서에서 확인하세요.\n> https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html<br><br>\n> Built-in Function: void *__builtin_alloca_with_align (size_t size, size_t alignment)<br>\n> Built-in Function: void *__builtin_alloca_with_align_and_max (size_t size, size_t alignment, size_t max_size)\n\n`alloca`를 더욱 safe 하게 사용할 수 있도록 gcc 7.0에서는 alloca의 max size를 compile-time에 확인할 수 있는 compile option이 추가되었습니다.<br>\n또한 코드에서 `alloca`가 사용되었는지도 확인할 수 있습니다.<br><br>\n\n이것들은 이후 다른 post에서 설명하겠습니다.\n> -Walloca-larger-than, -Walloca ...\n\n만약 `alloca`를 사용하게 된다면, size와 range check에 신경 써야 합니다.<br>\n\n참고로 `alloca`를 inline function에서 사용할 경우 의도하지 않은 동작이 될 수도 있습니다.<br>\n이유는 구글링해 보시면 쉽게 아실 수 있습니다 :)\n\n\n***\n<ol>\n\n[^1]: variable-length array (VLA), also called variable-sized, runtime-sized, is an array data structure whose length is determined at run time instead of at compile time\n\n</ol>"
}