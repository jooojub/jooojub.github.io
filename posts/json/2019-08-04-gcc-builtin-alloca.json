{
 "content": "\n\n#### Requires\n: compiler: gcc 2.8 later\n***\n\nLet's take a look at <mark>__builtin_alloca</mark>, one of the gcc builtins.\n\nThe first thing to keep in mind is that many books and posts advise against using <mark>alloca</mark> built-in' from a `security standpoint`.\n\nI hope that through this post, you can clearly understand why.\n\nIf you've looked at open-source code a lot, you'll often see <mark>__builtin_alloca</mark>.\n\nFor example, glibc's `strdupa` macro is defined as follows:\n\n```c\n: strdupa macro (glibc/string/string.h)\n# define strdupa(s)\t\t\t\t\t\t\t   \t\t\t\\\n  (__extension__\t\t\t\t\t\t\t     \t\t\\\n    ({\t\t\t\t\t\t\t\t\t      \t\t\t\\\n      const char *__old = (s);\t\t\t\t\t\t\t\\\n      size_t __len = strlen (__old) + 1;\t\t\t\t\\\n      char *__new = (char *) __builtin_alloca (__len);\t\\\n      (char *) memcpy (__new, __old, __len);\t\t\t\\\n    }))\n```\n\n<mark>__builtin_alloca</mark> is a gcc built-in function that can be set to be allocated on the `stack` instead of the `heap` when allocating dynamic variables.\n\nSo if you look at glibc's `strdupa` code, you can see that it doesn't call free().\n\nSince it is not allocated on the heap like malloc(), its life-time becomes a `function block`.\n\nTherefore, as with any local variable, without a separate free(), the effect of freeing can be exerted only by restoring the stack pointer to the caller function.\n\nAs a result, both `cpu-time` and `memory` have advantages over malloc.\n\n<mark>__builtin_alloca</mark> is a function called by gcc at `compile-time`, not a function called by process at run-time.\nIt works like a macro, but not strictly a macro.\n\nYou can see that <mark>__builtin_alloca</mark> is converted to other code by gcc via disassemble.\n\n```x86asm\n: builtin_alloca was replaced to\nvoid func(size_t n, const char* src) {\n    ...\n\tchar *val = (char *)__builtin_alloca(n);\n 739:\t48 8b 45 e8          \tmov    -0x18(%rbp),%rax\n 73d:\t48 8d 50 0f          \tlea    0xf(%rax),%rdx\n 741:\tb8 10 00 00 00       \tmov    $0x10,%eax\n 746:\t48 83 e8 01          \tsub    $0x1,%rax\n 74a:\t48 01 d0             \tadd    %rdx,%rax\n 74d:\tb9 10 00 00 00       \tmov    $0x10,%ecx\n 752:\tba 00 00 00 00       \tmov    $0x0,%edx\n 757:\t48 f7 f1             \tdiv    %rcx\n 75a:\t48 6b c0 10          \timul   $0x10,%rax,%rax\n 75e:\t48 29 c4             \tsub    %rax,%rsp\n 761:\t48 89 e0             \tmov    %rsp,%rax\n 764:\t48 83 c0 0f          \tadd    $0xf,%rax\n 768:\t48 c1 e8 04          \tshr    $0x4,%rax\n 76c:\t48 c1 e0 04          \tshl    $0x4,%rax\n 770:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)\n\n\tmemcpy(val, src, n);\n\t...\n```\nYou can see that it is not in the form of a function call like `callq __builtin_alloca`\n\nThis builtin allocates a dynamic variable and is used where it is guaranteed to be used temporarily in a function, such as a local variable.\n\nLet's take a look at the gcc documentation.\n\n> #### Built-in Function: void *__builtin_alloca (size_t size)\n> The `__builtin_alloca` function must be called at block scope<br>.\n> The function allocates an object size bytes large on the stack of the calling function. The object is aligned on the default `stack` alignment boundary for the target determined by the __BIGGEST_ALIGNMENT__ macro.<br>\n> The __builtin_alloca function returns a pointer to the first byte of the allocated object.\nThe lifetime of the allocated object ends just before the <b>calling function returns to its caller</b>.<br>\n> This is so even when __builtin_alloca is called within a nested block.<br>\n> **ref:&nbsp;**<a target=\"_blank\" href=\"https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/Other-Builtins.html#Other-Builtins\"><code>https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/Other-Builtins.html#Other-Builtins</code></a></cite>\n\nI haven't looked closely at the gcc code, but it's a builtin that has been around since gcc 2.8.\n\nLet's easily check how to use it through the sample code.\n\n```c\n: sample code - alloca.c\n#include <stdio.h>\n#include <string.h>\n\nvoid func(const size_t n, const char* src) {\n\tchar *val = (char *)__builtin_alloca(n);\n\tstrncpy(val, src, n - 1);\n\tval[n - 1] = '\\0';\n\n\tprintf(\"val: %s\\n\", val);\n}\n\nint main(void) {\n\tfunc(4, \"simple\");\n\n\treturn 0;\n}\n```\n```bash\n: gcc version 7.4.0 --target=x86_64-linux-gnu\n$ gcc -g -o alloca alloca.c\n$ ./alloca\nval: sim\n```\n\n```x86asm\n: assembly - x86_64 AT&T\nvoid func(const size_t n, const char* src) {\n 6fa:\t55                   \tpush   %rbp\n 6fb:\t48 89 e5             \tmov    %rsp,%rbp\n 6fe:\t48 83 ec 20          \tsub    $0x20,%rsp\n 702:\t48 89 7d e8          \tmov    %rdi,-0x18(%rbp)\n 706:\t48 89 75 e0          \tmov    %rsi,-0x20(%rbp)\n 70a:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax\n 711:\t00 00 \n 713:\t48 89 45 f8          \tmov    %rax,-0x8(%rbp)\n 717:\t31 c0                \txor    %eax,%eax\n\tchar *val = (char *)__builtin_alloca(n);\n 719:\t48 8b 45 e8          \tmov    -0x18(%rbp),%rax\n 71d:\t48 8d 50 0f          \tlea    0xf(%rax),%rdx\n 721:\tb8 10 00 00 00       \tmov    $0x10,%eax\n 726:\t48 83 e8 01          \tsub    $0x1,%rax\n 72a:\t48 01 d0             \tadd    %rdx,%rax\n 72d:\tb9 10 00 00 00       \tmov    $0x10,%ecx\n 732:\tba 00 00 00 00       \tmov    $0x0,%edx\n 737:\t48 f7 f1             \tdiv    %rcx\n 73a:\t48 6b c0 10          \timul   $0x10,%rax,%rax\n 73e:\t48 29 c4             \tsub    %rax,%rsp\n 741:\t48 89 e0             \tmov    %rsp,%rax\n 744:\t48 83 c0 0f          \tadd    $0xf,%rax\n 748:\t48 c1 e8 04          \tshr    $0x4,%rax\n 74c:\t48 c1 e0 04          \tshl    $0x4,%rax\n 750:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)\n\tstrncpy(val, src, n);\n ...\n 7a6:\tc9                   \tleaveq \n 7a7:\tc3                   \tretq   \n```\n\nThe align routines were also added by the compiler, but the important part is that the stack size is just increased for variable allocation, and when the function returns, it simply `retq` without free().\n\nThe gcc documentation describes scope as follows:\n> The lifetime of the allocated object ends just before the calling function returns to its caller\n\nIn glibc 1.09, <mark>__builtin_alloca</mark> was defined as <mark>alloca</mark> to shorten the long names.\n\n```c\n: __builtin_alloca is defined as alloca in glibc/stdlib/alloca.h\n#ifdef\t__GNUC__\n# define alloca(size)\t__builtin_alloca (size)\n#endif /* GCC.  */\n```\nSo if you include `alloca.h`, you can simply use `alloca`.\n\nHowever, in my personal opinion, since gcc built-in is not a function called at run-time, but a function called by gcc at compile-time, I think it would be better to express the prefix <mark>__builtin</mark> as it is.\n\nHowever, this is simply a matter of coding style, and if it is a multi-person project, you can make a promise (coding rules) about how to use it and use it.\n\nIt looks like ->[^1]VLA[/^] supported by C99, but the lifetime is different from VLA.\n\nVLA litftime is block scope and <mark>alloca</mark> is function scope.\nThis means that the VLA cannot be used in the following situations:\n\n```c\n: It is impossible in VLA\n#define COUNT 10\n\nstruct sample {\n\tunsigned char *p_x;\n};\n\nvoid func(void) {\n\tstruct sample val[COUNT];\n\tint i;\n\n\tfor (i = 0; i < COUNT; i++) {\n\t\t/* Use VLA */\n\t\tunsigned char x[i];\n\t\t/* unsigned char *x = (unsigned char *)__builtin_alloca(i); */\n\t\tmemset(x, 0, i);\n\n\t\tval[i].p_x = x;\n\t\t/* The lifetime of x is terminated */\n\t}\n\n\tsumthing_to_do(val);\n\n\treturn;\n}\n```\n\nAs mentioned above, many books and posts advise against using VLA or alloca that dynamically allocates variables on the stack because they are un-safe in terms of security, and I agree.\nCode that dynamically allocates variables on the stack can cause a stack overflow, which can be a security hole.\nAnd also, if a negative number is used for length, the code may flow in an entirely unintended direction.\nAnd it can confuse people who don't know </mark>alloca</mark> because it's different from the alloc/free pairing commonly used for dynamic allocation in Standard C.\n> alloca is not standard - it is a GNU extension\n\nFor the above reasons, the kernel project made a lot of effort to remove the VLA code, and as a result, it was completely successful in 4.20.\n> https://www.phoronix.com/scan.php?page=news_item&px=Linux-Kills-The-VLA\n\nThe GNU documentation describes the benefits of <mark>alloca</mark> as follows:\n\n> #### Advantages-of-Alloca\n> * Using alloca wastes very <b>little space</b> and is very <b>fast</b>. (It is open-coded by the GNU C compiler.)<br>\n> * Since alloca does not have separate pools for different sizes of blocks, space used for any size block can be reused for any other size. alloca <b>does not cause memory fragmentation.</b><br>\n> * Nonlocal exits done with longjmp (see Non-Local Exits) automatically free the space allocated with alloca when they exit through the function that called alloca. This is the most important reason to use alloca.\n> **ref:&nbsp;**<a target=\"_blank\" href=\"https://www.gnu.org/software/libc/manual/html_node/Advantages-of-Alloca.html#Advantages-of-Alloca\"><code>https://www.gnu.org/software/libc/manual/html_node/Advantages-of-Alloca.html#Advantages-of-Alloca</code></a></cite>\n\nThe disadvantages are described as follows.\n\n> #### Disadvantages-of-Alloca\n> * If you try to allocate more memory than the machine can provide, you donâ€™t get a clean error message. Instead you get a fatal signal like the one you would get from an infinite recursion; probably a segmentation violation (see Program Error Signals).<br>\n> * Some non-GNU systems fail to support alloca, so it is less portable. However, a slower emulation of alloca written in C is available for use on systems with this deficiency.\n> **ref:&nbsp;**<a target=\"_blank\" href=\"https://www.gnu.org/software/libc/manual/html_node/Disadvantages-of-Alloca.html#Disadvantages-of-Alloca\"><code>https://www.gnu.org/software/libc/manual/html_node/Disadvantages-of-Alloca.html#Disadvantages-of-Alloca</code></a></cite>\n\n`__builtin_alloca_with_align` was added in gcc 4.7 and `__builtin_alloca_with_align_and_max` was added in gcc 8.1.\nAdded to be able to set max_size or align to make <mark>alloca</mark> safer to use.\n\nIt's a simple addition. Check out the documentation.\n\n> #### https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html<br>\n> * Built-in Function: void *__builtin_alloca_with_align (size_t size, size_t alignment)<br>\n> * Built-in Function: void *__builtin_alloca_with_align_and_max (size_t size, size_t alignment, size_t max_size)\n\nTo make <mark>alloca</mark> safer to use, gcc 7.0 has added a compile option that can check the max size of alloca at compile-time.\nYou can also check if <mark>alloca</mark> is used in your code at compile time.\n\nThese will be explained later in another post.\n> -Walloca-larger-than, -Walloca ...\n\nIf you're going to use <mark>alloca</mark>, you'll need to pay attention to size and range checks.\n\nNote that using <mark>alloca</mark> in an inline function may result in unintended behavior.\nYou can easily find out why if you google it :)\n\n***\n<ol>\n\n[^1]: variable-length array (VLA), also called variable-sized, runtime-sized, is an array data structure whose length is determined at run time instead of at compile time\n\n</ol>"
}