{
 "content": "\n\nRequires :\n * compiler: gcc 2.8 later\n\n만약 compile option 없이 `char`를 사용한다면, `signed` 일까요 `unsigned`? <br>\n결과는 architecture에 따라, 그리고 compiler version에 따라 다를 것입니다.\n\n많은 사람들은 대부분 `char`는 `signed char`라고 생각하며 코드를 작성합니다.<br>\n그러나 이건 architecture 또는 compiler option에 따라 다르기 때문에 위험한 코드입니다.<br>\n특히 architecture independent code를 작성해야 한다면 절대로 피해야 하는 코딩 습관입니다.\n\ngcc compiler에는 `char`를 `signed` 또는 `unsigned`로 다룰지에 대한 gcc option[^1]이 있다.\n\n[^1]: gcc 문서에는 <b>gcc commands</b>라고 명명하고 있습니다. 저는 두 용어 모두 혼용해서 사용하겠습니다 :)\n> -fsigned-char, -funsigned-char, -fno-signed-char\", -fno-unsigned-char\n\n많은 option이 있지만 결국은 두 가지 의미로 사용됩니다.\n> <b>char -> signed char</b>: -fsigned-char == -fno-unsigned-char<br>\n> <b>char -> unsigned char</b>: -funsigned-char == -fno-signed-char\n\n아주 심플한 gcc option이며, gcc 문서에서도 자세히 설명되어 있습니다.\n\n***\n<table>\n    <thead>\n        <tr>\n            <th>gcc-7.4.0/C-Dialect-Options</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n                <b>-funsigned-char</b><br>\n                Let the type <b>char</b> be <b>unsigned</b>, like <b>unsigned char</b>.<br>\n                <b>Each kind of machine has a default for what char should be. It is either like unsigned char by default or like signed char by default</b>.\n                Ideally, a portable program should always use signed char or unsigned char when it depends on the signedness of an object. But many programs have been written to use plain <b>char</b> and <b>expect it to be signed, or expect it to be unsigned</b>, depending on the machines they were written for. This option, and its inverse, let you make such a program work with the opposite default.<br>\n                The type char is always a distinct type from each of signed char or unsigned char, even though its behavior is always just like one of those two.\n                <br><br>\n                <cite>ref. <a href=\"https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/C-Dialect-Options.html#C-Dialect-Optionsl\"><code>https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/C-Dialect-Options.html#C-Dialect-Options</code></a></cite>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n***\n이 option이 처음 등장했던 gcc version을 자세히 살펴보진 않았지만, gcc 2.8에는 이미 해당 option이 포함되어 있습니다.\n\n#### -> git checkout gcc-2_8_0-release\n{% highlight c %}\n$ cat ./gcc/toplev.c\n\nchar *lang_options[] =\n{\n\t...\n  \"-fsigned-char\",\n  \"-funsigned-char\",\n  \"-fno-signed-char\",\n  \"-fno-unsigned-char\",\n  ...\n{% endhighlight %}\ngcc release note에서는 찾아볼 수 없으나, cpp에서는 gcc 3.1에 추가된 걸로 보입니다.\n#### -> git checkout gcc-3_1-release\n{% highlight c %}\n$ cat ./gcc/cppinit.c\n\n#define COMMAND_LINE_OPTIONS                                      \\\n....\n  DEF_OPT(\"fsigned-char\",             0,      OPT_fsigned_char)\n...\n  DEF_OPT(\"funsigned-char\",           0,      OPT_funsigned_char)\n\n{% endhighlight %}\noption이 의도대로 잘 동작하는지 코드로 살펴봅시다.\n### Check with code\n#### -> sample source code: char.c\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n\tchar a = (1 << 8) - 1;\n\n\tprintf(\"%d\\n\", a);\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> gcc version 7.4.0 --target=x86_64-linux-gnu\n{% highlight bash %}\n$ gcc -o char char.c \n$ ./char\n-1\n{% endhighlight %}\nx86_64에서는 `char`를 `signed char`로 취급합니다.\n`-funsigned-char` option을 추가해 봅시다.\n#### -> gcc version 7.4.0 --target=x86_64-linux-gnu\n{% highlight bash %}\n$ gcc -funsigned-char -o char char.c \n$ ./char\n255\n{% endhighlight %}\n`-funisgned-char` option이 추가되어 `char`를 `unsigned char`로 취급합니다.\n\n각 architecture 별로 `char`를 어떻게 다루는지 살펴보았습니다.\n#### -> x86_64: default signed char\n{% highlight x86asm %}\n...\n 652:\tc6 45 ff ff          \tmovb   $0xff,-0x1(%rbp)\n /* \n  - movsbl (Move a Sign-extended Byte): signed char\n  - movzbl (Move a Zero-extended Byte): unsigned char\n */\n 656:\t0f be 45 ff          \tmovsbl -0x1(%rbp),%eax\n...\n{% endhighlight %}\n#### -> aarch64: default unsigned char\n{% highlight armasm %}\n...\n 72c:\t12800000 \tmov\tw0, #0xffffffff            \t// #-1\n 730:\t39007fa0 \tstrb\tw0, [x29, #31]\n /*\n  - ldrsb (Load Register Signed Byte): signed char\n  - ldrb (Load Register Byte): unsigned char\n */\n 734:\t39407fa1 \tldrb\tw1, [x29, #31]\n...\n{% endhighlight %}\n#### -> mips64: default signed char\n{% highlight mipsasm %}\n...\n 10000b20:\t2402ffff \tli\tv0,-1\n 10000b24:\ta3c20000 \tsb\tv0,0(s8)\n /*\n  - lb (Load Byte): signed char\n  - lbu (Load Byte unsigned): unsigned char\n */\n 10000b28:\t83c20000 \tlb\tv0,0(s8)\n...\n{% endhighlight %}\n#### -> ppc: default unsigned char\n{% highlight x86asm %}\n /*\n  - lis (Load Immediate Shifted): signed char\n  - li (Load Immediate): unsigned char\n */\n 1000046c:\t38 00 ff ff \tli      r0,-1\n 10000470:\t98 1f 00 0a \tstb     r0,10(r31)\n{% endhighlight %}\nstack overflow에서 `char`가 `signed`인지 `unsigned`인지를 쉽게 확인할 수 있는 sample code를 찾았습니다.\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n  printf(\"%d\\n\", '\\x80');\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> result\n{% highlight bash %}\n$ gcc -o simple simple.c \n$ ./simple\n-128\n\n$ gcc -funsigned-char -o simple simple.c \n$ ./simple\n128\n{% endhighlight %}\n거대한 project에서는 global 하게 compile option이 추가되기 때문에, 각 process 별로 compile option을 통일하는 게 일반적입니다.\n\n즉, compile option에 의존해서 코드를 작성하는 것 보다는 signed 인지 unsigned 인지가 중요한 코드에서는 `char`가 아닌 명시적으로 `signed char` 또는 `unsigned char`를 이용해서 코드를 작성하는 게 좋아 보입니다.\n<div align=\"right\">\njooojub.\n</div>\n"
}