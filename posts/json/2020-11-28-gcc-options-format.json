{
 "content": "\n\nRequires :\n * compiler: gcc 2.8 later\n * glibc 2.2 later\n\nprintf 와 같이 format을 사용하는 glibc 함수들을 사용할 때, 잘못된 format을 사용할 경우 compile warning이 발생하는 것을 종종 보았을 것입니다.\n#### -> If format is used incorrectly, a compile warning occurs.\n{% highlight c %}\n$ cat ./format_warning.c\n#include <stdio.h>\n\nint main(void) {\n\tprintf(\"%d, %d\\n\", (int)1, (unsigned long)2);\n\n\treturn 0;\n}\n{% endhighlight %}\n{% highlight bash %}\n$ gcc -o format_warning format_warning.c\nformat_warning.c: In function ‘main’:\nformat_warning.c:4:15: warning: format ‘%d’ expects argument \\\n  of type ‘int’, but argument 3 has type ‘long unsigned int’ [-Wformat=]\n  printf(\"%d, %d\\n\", (int)1, (unsigned long)2);\n              ~^             ~~~~~~~~~~~~~~~~\n{% endhighlight %}\ncompiler라 `unsigned long`을 왜 `%d`로 출력하려고 하냐고 친절하게 warning으로 알려줍니다.<br>\nargument type 뿐만 아니라 argument 갯수가 잘못된 상황도 warning으로 보여줍니다.\n#### -> Even if the number of arguments is incorrectly set.\n{% highlight c %}\n$ cat ./format_warning2.c\n#include <stdio.h>\n\nint main(void) {\n\tprintf(\"%d, %d\\n\", 1);\n\n\treturn 0;\n}\n{% endhighlight %}\n{% highlight bash %}\n$ gcc -o format_warning2 format_warning2.c\nformat_warning2.c: In function ‘main’:\nformat_warning2.c:4:15: warning: format ‘%d’ expects a matching ‘int’ argument [-Wformat=]\n    printf(\"%d, %d\\n\", 1);\n{% endhighlight %}\n\n-Wformat에 대해서 우선 gcc 문서를 살펴 보겠습니다.\n\n***\n<table>\n    <thead>\n        <tr>\n            <th>gcc-7.5.0/Warning-Options</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n                <b>-Wformat</b><br>\n                <b>-Wformat=n</b><br>\n                Check calls to <b>printf</b> and <b>scanf</b>, etc.,<br>\n                to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.<br> This includes <b>standard functions</b>, and <b>others specified by format attributes</b> (see Function Attributes),<br> in the printf, scanf, strftime and strfmon (an X/Open extension, not in the C standard) families (or other target-specific families).<br> Which functions are checked without format attributes having been specified depends on the standard version selected, and such checks of functions without the attribute specified are disabled by -ffreestanding or -fno-builtin.<br><br>\n                The formats are checked against the format features supported by <b>GNU libc version 2.2</b>.<br> These include all ISO C90 and C99 features, as well as features from the Single Unix Specification and some BSD and GNU extensions.<br>Other library implementations may not support all these features; GCC does not support warning about features that go beyond a particular library’s limitations.<br> However, if <b>-Wpedantic</b> is used with <b>-Wformat</b>, warnings are given about format features not in the selected standard version (but not for strfmon formats, since those are not in any version of the C standard).\n                <br><br>\n                <cite>ref. <a href=\"https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Warning-Options.html#Warning-Options\"><code>https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Warning-Options.html#Warning-Options</code></a></cite>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n***\n\nglibc 2.2 이후의 몇몇 standard function에 대해서 지원한다고 나와 있습니다.<br>\n그럼 glibc의 어떤 함수들이 `-Wformat`을 지원할까요?<br>\ngcc 코드를 살펴보면 지원되는 함수 종류들을 볼 수 있습니다.\n\n#### -> git checkout releases/gcc-3.0\n{% highlight c %}\n$ cat ./gcc/c-format.c\n...\nvoid\ninit_function_format_info ()\n{\n  if (flag_hosted)\n    {\n      /* Functions from ISO/IEC 9899:1990.  */\n      record_function_format (get_identifier (\"printf\"), NULL_TREE,\n\t\t\t      printf_format_type, 1, 2);\n      record_function_format (get_identifier (\"__builtin_printf\"), NULL_TREE,\n\t\t\t      printf_format_type, 1, 2);\n      record_function_format (get_identifier (\"fprintf\"), NULL_TREE,\n\t\t\t      printf_format_type, 2, 3);\n      record_function_format (get_identifier (\"__builtin_fprintf\"), NULL_TREE,\n\t\t\t      printf_format_type, 2, 3);\n      record_function_format (get_identifier (\"sprintf\"), NULL_TREE,\n\t\t\t      printf_format_type, 2, 3);\n      record_function_format (get_identifier (\"scanf\"), NULL_TREE,\n\t\t\t      scanf_format_type, 1, 2);\n      record_function_format (get_identifier (\"fscanf\"), NULL_TREE,\n\t\t\t      scanf_format_type, 2, 3);\n      record_function_format (get_identifier (\"sscanf\"), NULL_TREE,\n\t\t\t      scanf_format_type, 2, 3);\n      record_function_format (get_identifier (\"vprintf\"), NULL_TREE,\n\t\t\t      printf_format_type, 1, 0);\n      record_function_format (get_identifier (\"vfprintf\"), NULL_TREE,\n\t\t\t      printf_format_type, 2, 0);\n      record_function_format (get_identifier (\"vsprintf\"), NULL_TREE,\n\t\t\t      printf_format_type, 2, 0);\n      record_function_format (get_identifier (\"strftime\"), NULL_TREE,\n\t\t\t      strftime_format_type, 3, 0);\n    }\n\n  if (flag_hosted && flag_isoc99)\n    {\n      /* ISO C99 adds the snprintf and vscanf family functions.  */\n      record_function_format (get_identifier (\"snprintf\"), NULL_TREE,\n\t\t\t      printf_format_type, 3, 4);\n      record_function_format (get_identifier (\"vsnprintf\"), NULL_TREE,\n\t\t\t      printf_format_type, 3, 0);\n      record_function_format (get_identifier (\"vscanf\"), NULL_TREE,\n\t\t\t      scanf_format_type, 1, 0);\n      record_function_format (get_identifier (\"vfscanf\"), NULL_TREE,\n\t\t\t      scanf_format_type, 2, 0);\n      record_function_format (get_identifier (\"vsscanf\"), NULL_TREE,\n\t\t\t      scanf_format_type, 2, 0);\n    }\n  ...\n{% endhighlight %}\ngcc 코드는 너무 복잡해서 자세히는 이해 못 했지만, 크게 `printf`, `scanf`, `strftime`로 분류하는 것으로 보입니다.<br><br>\n그렇다면 glibc standard 함수가 아닌 `va_arg()`를 이용해 정의한 자신만의 함수도 `-Wformat`의 검출 대상으로 추가하는 방법은 없을까요?<br>\n위 문서에서도 살짝 언급했듯 `__attribute__((format))`를 사용하면 됩니다.<br>\n`__attribute__((format))`에 대해서는 다른 post에서 자세히 설명하겠습니다.<br>\n(사실 `__attribute__((format))`를 소개하고 싶어서 `-Wformat`를 먼저 설명하고 있는 것입니다...)<br>\n\n`-Wformat` 종류의 option은 많은 종류가 있습니다. 이것들에 대해서 간략하게 확인해봅시다.<br>\ngcc-7.5.0 기준으로 알아보겠습니다.<br>\n\n\n\n\n## -Wformat-contains-nul\nformat에 NUL string('\\0')이 포함되어 있는지를 검사합니다.\n#### -> sample source code: format_contains_nul.c\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n    char buf[16];\n    sprintf(buf, \"%s\\0\", \"test\");\n\n    return 0;\n}\n{% endhighlight %}\n#### -> compile\n{% highlight bash %}\n$ gcc -o format_contains_nul format_contains_nul.c -Wformat-contains-nul\n{% endhighlight %}\n#### -> output\n{% highlight bash %}\nformat_contains_nul.c: In function ‘main’:\nformat_contains_nul.c:5:21: warning: embedded ‘\\0’ in format [-Wformat-contains-nul]\n    5 |     sprintf(buf, \"%s\\0\", \"test\");\n      |                     ^~\n{% endhighlight %}\n\n\n\n\n## -Wformat-extra-args\nformat의 specifiers 보다 argument 개수가 많을 경우를 검사합니다.\n#### -> sample source code: format_extra_args.c\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n    printf(\"excess arguments: %s\", __LINE__, \"what\");\n\n    return 0;\n}\n{% endhighlight %}\n#### -> compile\n{% highlight bash %}\n$ gcc -o format_extra_args format_extra_args.c -Wformat-extra-args\n{% endhighlight %}\n#### -> output\n{% highlight bash %}\nformat_extra_args.c: In function ‘main’:\n...\nformat_extra_args.c:4:12: warning: too many arguments for format [-Wformat-extra-args]\n    4 |     printf(\"excess arguments: %s\", __LINE__, \"what\");\n{% endhighlight %}\n\n\n\n\n## -Wformat-overflow\nsprintf나 vsprintf와 같이 format에 따라 destination buffer에 쓰는 경우,\nbuffer size 보다 큰 값이 들어와 overflow가 발생하는지를 검사합니다.\n#### -> sample source code: format_overflow.c\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n    char buf[10];\n    sprintf(buf, \"overflow %s\", \"ho!\");\n\n    return 0;\n}\n{% endhighlight %}\n#### -> compile\n{% highlight bash %}\n$ gcc -o format_overflow format_overflow.c -Wformat-overflow\n{% endhighlight %}\n#### -> output\n{% highlight bash %}\nformat_overflow.c: In function ‘main’:\nformat_overflow.c:5:28: warning: ‘%s’ directive writing 3 bytes into a region of size 1 [-Wformat-overflow=]\n    5 |     sprintf(buf, \"overflow %s\", \"ho!\");\n      |                            ^~   ~~~~~\nformat_overflow.c:5:5: note: ‘sprintf’ output 13 bytes into a destination of size 10\n    5 |     sprintf(buf, \"overflow %s\", \"ho!\");\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n{% endhighlight %}\n만약 compile time에 예측하기 힘든 상황에서는 어떻게 될까요?\n\n#### -> sample source code: format_overflow.c\n{% highlight c %}\n#include <stdio.h>\n\nint main(int argc, const char *argv[]) {\n    char buf[10];\n    sprintf(buf, \"overflow %s\", argv[0]);\n\n    return 0;\n}\n{% endhighlight %}\n#### -> compile\n{% highlight bash %}\n$ gcc -o format_overflow format_overflow.c -Wformat-overflow\n{% endhighlight %}\n#### -> output\n{% highlight c %}\n...\n{% endhighlight %}\n사실 argv 값에 상관없이 format에 의해 이미 buffer overflow가 발생하는 코드지만,\n-Wformat-overflow가 overflow를 감지하지 못하고 있습니다.\n\n이럴 때는 Wformat-overflow의 level을 지정하면 됩니다.\n#### -> compile with -Wformat-overflow=2\n{% highlight bash %}\n$  gcc -o format_overflow format_overflow.c -Wformat-overflow=2\n{% endhighlight %}\n#### -> output\n{% highlight bash %}\nformat_overflow.c: In function ‘main’:\nformat_overflow.c:5:30: warning: ‘sprintf’ may write a terminating nul past the end of the destination [-Wformat-overflow=]\n    5 |     sprintf(buf, \"overflow %s\", argv[0]);\n      |                              ^\nformat_overflow.c:5:5: note: ‘sprintf’ output 10 or more bytes (assuming 11) into a destination of size 10\n    5 |     sprintf(buf, \"overflow %s\", argv[0]);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n{% endhighlight %}\n\n\n\n\n## -Wformat-zero-length\nformat이 zero length일 경우를 검사합니다.\n#### -> sample source code: format_zero_length.c\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n    printf(\"\",\"zero-length\");\n    return 0;\n}\n{% endhighlight %}\n#### -> compile\n{% highlight bash %}\n$ gcc -o format_zero_length format_zero_length.c -Wformat-zero-length\n{% endhighlight %}\n#### -> output\n{% highlight bash %}\nformat_zero_length.c: In function ‘main’:\nformat_zero_length.c:4:12: warning: zero-length gnu_printf format string [-Wformat-zero-length]\n    4 |     printf(\"\",\"zero-length\");\n      |            ^~\n{% endhighlight %}\n사실상 이런 코드는 작성될 리가 없겠죠? 하지만 이런 코드는 의외로 자주 발생됩니다.\n{% highlight c %}\n    const char fmt[] = \"\";\n    printf(fmt,\"zero-length\");\n{% endhighlight %}\n\n\n\n\n\n## -Wformat-nonliteral\nformat이 string literal 인지 검사합니다.\n#### -> sample source code: format_nonliteral.c\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n    char fmt[] = \"%s\";\n    printf(fmt,\"test\");\n\n    return 0;\n}\n{% endhighlight %}\n#### -> compile\n{% highlight bash %}\n$ gcc -o format_nonliteral format_nonliteral.c -Wformat-nonliteral\n{% endhighlight %}\n#### -> output\n{% highlight bash %}\nformat_nonliteral.c: In function ‘main’:\nformat_nonliteral.c:5:12: warning: format not a string literal, argument types not checked [-Wformat-nonliteral]\n    5 |     printf(fmt,\"test\");\n      |            ^~~\n{% endhighlight %}\nfmt를 const char로 지정할 경우 이 warning은 사라지게 됩니다.\n{% highlight diff %}\n- char fmt[] = \"%s\";\n+ const char fmt[] = \"%s\";\n{% endhighlight %}\n하지만 경우에 따라 fmt를 dynamic 하게 변경해야 하는 코드를 작성해야 하는 경우도 있습니다.\n{% highlight c %}\n#include <stdio.h>\n\nchar* get_format(int value) {\n    if (value == 1)\n        return \"%d\";\n    else\n        return \"%s\";\n}\n\nint main(void) {\n    printf(get_format(1),\"test\");\n\n    return 0;\n}\n{% endhighlight %}\n그래서 경우에 따라 이 option을 무시하는 코드를 추가하기도 합니다.\n{% highlight c %}\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n...\n#pragma GCC diagnostic warning \"-Wformat-nonliteral\"\n{% endhighlight %}\n\n\n\n## -Wformat-security\nformat이 string iternal이 아니면서, argument가 없을 경우를 감지합니다.<br>\n#### -> sample source code: format_security.c\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n    char *fmt = \"%s\";\n    printf(fmt);\n\n    return 0;\n}\n{% endhighlight %}\n#### -> compile\n{% highlight bash %}\n$ gcc -o format_security format_security.c -Wformat-security\n{% endhighlight %}\n#### -> output\n{% highlight bash %}\nformat_security.c: In function ‘main’:\nformat_security.c:5:5: warning: format not a string literal and no format arguments [-Wformat-security]\n    5 |     printf(fmt);\n      |     ^~~~~~\n{% endhighlight %}\n이것을 감지하는 이유는 무엇일까요? option 이름이 security인 이유가 있습니다.<br>\nnon-iternal string일 경우 format을 `%n`으로 변경 가능하며, stack overflow 등을 통해서 arugment를 조작 가능하기 때문에 `Format String Bug Exploration` 가능한 코드가 됩니다.<br>\n즉 security hole이 있는 코드가 됩니다.<br>\n`Format String Bug Exploration`에 대해서는 기회가 된다면 post로 다뤄볼 계획입니다.\n\n\n\n\n## -Wformat-signedness\n이름 그대로 format이 signed인데 argument를 unsigned로 사용했을 경우, 또는 그 반대의 경우를 감지합니다.\n#### -> sample source code: format_signedness\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n    unsigned int a = 10;\n    signed int b = -10;\n\n    printf(\"%d %u\", a, b);\n\n    return 0;\n}\n{% endhighlight %}\n#### -> compile\n{% highlight bash %}\n$ gcc -o format_signedness format_signedness.c -Wformat-signedness\n{% endhighlight %}\n#### -> output\n{% highlight bash %}\nformat_signedness.c: In function ‘main’:\nformat_signedness.c:7:14: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘unsigned int’ [-Wformat=]\n    7 |     printf(\"%d %u\", a, b);\n      |             ~^      ~\n      |              |      |\n      |              int    unsigned int\n      |             %d\nformat_signedness.c:7:17: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 3 has type ‘int’ [-Wformat=]\n    7 |     printf(\"%d %u\", a, b);\n      |                ~^      ~\n      |                 |      |\n      |                 |      int\n      |                 unsigned int\n      |                %u\n{% endhighlight %}\n\n\n\n\n\n## -Wformat-truncation\nsnprintf와 같이 length를 지정하는 function에 의해 결과가 잘린다는 것을 감지하고 경고해 줍니다.\n#### -> sample source code: format_truncation\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n    char buf[10];\n    snprintf(buf, sizeof(buf), \"%s\", \"string truncation\");\n\n    return 0;\n}\n{% endhighlight %}\n#### -> compile\n{% highlight bash %}\n$ gcc -o format_truncation format_truncation.c -Wformat-truncation\n{% endhighlight %}\n#### -> output\n{% highlight bash %}\nformat_truncation.c: In function ‘main’:\nformat_truncation.c:5:33: warning: ‘%s’ directive output truncated writing 17 bytes into a region of size 10 [-Wformat-truncation=]\n    5 |     snprintf(buf, sizeof(buf), \"%s\", \"string truncation\");\n      |                                 ^~   ~~~~~~~~~~~~~~~~~~~\nformat_truncation.c:5:5: note: ‘snprintf’ output 18 bytes into a destination of size 10\n    5 |     snprintf(buf, sizeof(buf), \"%s\", \"string truncation\");\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n{% endhighlight %}\n\n위와 같은 문제들은 사소해 보일 수도 있지만, 상황에 따라 runtime에 stack overflow가 발생할 수도 있으며, security hole이 될 수도 있습니다.<br>\n프로젝트가 커질수록 이러한 문제들을 Compile time에 인지하고 미리 수정 가능하다는 것이 큰 이점으로 작용할 수 있습니다.<br>\n따라서, 최대한 compile option에 `-Wformat` 혹은 `-Werror=format`을 추가하는 것을 권장 드립니다.\n<div align=\"right\">\njooojub.\n</div>"
}