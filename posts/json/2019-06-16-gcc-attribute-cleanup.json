{
 "content": "\n\nRequires :\n * compiler: gcc 3.3.1 later\n\nsystemd 코드에서, 'attribute' keyword 들을 많이 볼 수 있습니다. 그중에서 security coding에 많은 도움이 될 수 있는 'cleanup' keyword에 대해서 살펴보겠습니다.\n\n'cleanup' keyword에 대해서 gcc 문서에서는 다음과 같이 설명합니다.\n\n***\n<table>\n    <thead>\n        <tr>\n            <th>cleanup</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n                <b>The cleanup attribute runs a function when the variable goes out of scope</b>. This attribute can only be applied to auto function scope variables; it may not be applied to parameters or variables with static storage duration. The function must take one parameter, a pointer to a type compatible with the variable. The return value of the function (if any) is ignored.\n                <br><br>\n                If -fexceptions is enabled, then cleanup_function is run during the stack unwinding that happens during the processing of the exception. Note that the cleanup attribute does not allow the exception to be caught, only to perform an action. It is undefined what happens if cleanup_function does not return normally.\n                <br><br>\n                <cite>ref. <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html\"><code>https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html</code></a></cite>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n***\n다음 설명이 중요한 요점 같네요.\n> The cleanup attribute runs a function when the variable goes out of scope\n\n즉, 잘 사용한다면, pair를 맞춰야 하는 코드 {malloc/free, open/close, ...} 관리가 편해, leak이 발생하는 상황을 막을 수 있어 보입니다.\n### Check with code\n#### -> sample source code: simple\n{% highlight c %}\n#include <stdio.h>\n\nvoid auto_function(int *arg) {\n\tprintf(\"%s: called by __clean_up__: %d\\n\", __func__, *arg);\n\n\treturn;\n}\n\nint main(int argc, char **argv) {\n\t__attribute__ ((__cleanup__(auto_function))) int val = 5;\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> result\n{% highlight bash %}\nauto_function: called by __clean_up__: 5\n{% endhighlight %}\n\n#### -> assembly: x86_64 AT&T\n{% highlight x86asm %}\n00000000004005c1 <main>:\n  ...\n  4005ec:\t48 8d 45 e4             lea    -0x1c(%rbp),%rax\n  4005f0:\t48 89 c7                mov    %rax,%rdi\n  4005f3:\te8 9e ff ff ff          callq  400596 <auto_function>\n  ...\n{% endhighlight %}\nauto_function(& val)이 자동으로 호출되는 것을 볼 수 있습니다.<br>\n이곳에 free() 또는 close()를 추가하게 되면 신경 쓰지 않아도 자동으로 호출되게 할 수 있습니다.\n\n#### -> sample source code: fclose\n{% highlight c %}\n...\nvoid fclosep(FILE **f) {\n\tfclose(f);\n}\n\nint main(int argc, char **argv) {\n\t__attribute__ ((__cleanup__(fclosep))) FILE *f = fopen(name, \"r\");\n    ...\n    /* We don't need to call fclose(f) manually */\n\n\treturn 0;\n}\n{% endhighlight %}\n`__cleanup__` attribute에 의해 호출되는 함수의 시점이 중요합니다.<br>\n문서에는 다음과 같이 명시되어 있습니다.<br>\n`The cleanup attribute runs a function when the variable goes out of scope`<br>\n확인해봅시다.\n\n#### -> sample source code: scope\n{% highlight c %}\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid freep(void *p) {\n\tfree(*(void **) p);\n\tprintf(\"value freed\\n\");\n}\n\nint main(int argc, char **argv) {\n\t{\n\t\t__attribute__ ((__cleanup__(freep))) void *p = malloc(10);\n\t}\n\n\tprintf(\"before return\\n\");\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> result\n<div class=\"noline\" markdown=\"1\">\n{% highlight bash%}\nvalue freed\nbefore return\n{% endhighlight %}\n</div>\n\n#### -> assembly: x86_64 AT&T\n{% highlight x86asm %}\n  ...\n  40066a:\t31 c0                \txor    %eax,%eax\n\t{\n\t\t__attribute__ ((__cleanup__(freep))) void *p = malloc(10);\n  40066c:\tbf 0a 00 00 00       \tmov    $0xa,%edi\n  400671:\te8 9a fe ff ff       \tcallq  400510 <malloc@plt>\n  400676:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)\n  40067a:\t48 8d 45 f0          \tlea    -0x10(%rbp),%rax\n  40067e:\t48 89 c7             \tmov    %rax,%rdi\n     # The function is called by the life cycle of the variable\n  400681:\te8 a0 ff ff ff       \tcallq  400626 <freep>\n\t}\n\n\tprintf(\"before return\\n\");\n  400686:\tbf 40 07 40 00       \tmov    $0x400740,%edi\n  40068b:\te8 50 fe ff ff       \tcallq  4004e0 <puts@plt>\n\n\treturn 0;\n  400690:\tb8 00 00 00 00       \tmov    $0x0,%eax\n}\n\n{% endhighlight %}\n즉, 다음과 같은 실수를 하지 않도록 조심해야 합니다.\n\n#### -> sample source code: be careful with scope\n{% highlight c %}\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid freep(void *p) {\n\tfree(*(void **) p);\n}\n\nvoid *new_buffer(int size) {\n\t__attribute__ ((__cleanup__(freep))) int *p = malloc(size);\n\n\treturn p;\n}\n\nint main(int argc, char **argv) {\n\tchar *value = NULL;\n\n\tvalue = (char *)new_buffer(5);\n\tstrncpy(value, \"test\", 5);\n\n\tprintf(\"value: %s\\n\", value);\n\n\treturn 0;\n}\n{% endhighlight %}\n\n{% highlight bash %}\nSegmentation fault (core dumped)\n{% endhighlight %}\n\n<div align=\"right\">\njooojub.\n</div>\n"
}