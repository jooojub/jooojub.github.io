{
 "content": "\n\nRequires :\n * compiler: gcc 2.8.0 later\n\nPrior knowledge:\n * gcc options: [-Wformat]({% post_url 2020-11-28-gcc-options-format %})\n\n이전 [post]({% post_url 2020-11-28-gcc-options-format %})에서 다뤘듯이 gcc option의 -Wformat를 이용하면 printf, scanf와 같이 arugment를 다루는 glibc 함수 사용 시 format 관련 실수를 compile-time에 확인할 수 있어 많은 이점이 있다고 하였습니다.\n\n그렇다면 printf, scanf와 같이 glibc 함수가 아닌 다른 함수에서는 -Wformat의 도움을 받을 수 없을까요?<br>\n다음과 같은 코드를 작성했다고 가정해 보겠습니다.\n\n#### -> sample source code: format\n{% highlight c %}\n#include <stdio.h>\n#include <stdarg.h>\n\nint report(const char *fmt, ...) {\n\tva_list arg;\n\n\tva_start(arg, fmt);\n\tvfprintf(stderr, fmt, arg);\n\tva_end(arg);\n\n\treturn 0;\n}\n\nint main(void) {\n\treport(\"%s\\n\", \"report!\", \"excess\");\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> Compile with -Wformat\n<div class=\"noline\" markdown=\"1\">\n{% highlight bash %}\n$ gcc -o format format.c -Wformat\n...\n{% endhighlight %}\nreport의 format과 argument의 개수가 맞지 않음에도 아무런 warning 없이 컴파일 성공하였습니다.<br>\n그렇다면 제가 작성한 report() 함수의 -Wformat 지원을 위해서는 어떻게 해야 할까요?<br>\ngcc 문서를 잘 찾아보면, `format`이라는 `attribute`를 찾을 수 있습니다.\n\n***\n<table>\n    <thead>\n        <tr>\n            <th>format (archetype, string-index, first-to-check)</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n                The format attribute specifies that a function takes <b>printf, scanf, strftime or strfmon</b> style arguments which should be type-checked against a format string.<br>\n                ...<br>\n                <cite>ref. <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html\"><code>https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html</code></a></cite>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n***\n\n설명이 좀 길어서 다 생략했습니다...<br>\n결론은 자신이 원하는 함수에도 `-Wformat`을 사용할 수 있다는 설명입니다.<br><br>\n그럼 위 예제 코드에서 `attribute foramt`을 추가해 compile-time에 -Wformat 검출 가능한 코드로 변경해 보겠습니다.\n\n#### -> sample source code: format.c\n{% highlight c %}\n#include <stdio.h>\n#include <stdarg.h>\n\n__attribute__((format(printf, 1, 2)))\nint report(const char *fmt, ...) {\n\tva_list arg;\n\n\tva_start(arg, fmt);\n\tvfprintf(stderr, fmt, arg);\n\tva_end(arg);\n\n\treturn 0;\n}\n\nint main(void) {\n\treport(\"%s\\n\", \"report!\", \"excess\");\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> Compile with -Wformat\n<div class=\"noline\" markdown=\"1\">\n{% highlight bash %}\n$ gcc -o format format.c -Wformat\n\nformat.c: In function ‘main’:\nformat.c:16:9: warning: too many arguments for format [-Wformat-extra-args]\n   16 |  report(\"%s\\n\", \"report!\", \"excess\");\n      |         ^~~~~~\n{% endhighlight %}\n제가 작성한 report 함수에 대해서도 `-Wformat` option에 의해 warning으로 검출되었습니다.<br><br>\n사용법은 간단합니다.\n<div class=\"noline\" markdown=\"1\">\n{% highlight c %}\n__attribute__((format(archetype, string-index, first-to-check)))\n{% endhighlight %}\n- archetype에는 `printf`, `scanf`, `strftime`을 사용할 수 있습니다. target에 따라 glibc의 gnu_*를 붙일 수도 있고, MinGW의 ms_*를 붙일수도 있다고 합니다.\n- string-index에는 `format argument`의 위치를 지정하면 됩니다. 중요한 점은 index가 0이 아닌 1부터 시작한다는 것입니다. 예제의 `int report(const char *fmt, ...)` 함수에서는 `fmt`가 첫 번째 argument이기 때문에 1을 지정했습니다.\n- first-to-check에는 argument에 위치를 지정하면 됩니다.\n\n참고로<br>\n`vprintf`와 같이 argument(like ...)가 없는 함수에는 `first-to-check`를 0으로 지정하면 됩니다.\n#### -> sample source code: format_vprintf.c\n{% highlight c %}\n#include <stdio.h>\n#include <stdarg.h>\n\n__attribute__((format(printf, 2, 0)))\nint _va_report(int n, const char *fmt, va_list ap) {\n    return vfprintf(stdout, fmt, ap);\n}\n\nint report(int n, ...) {\n\tva_list arg;\n\n\tva_start(arg, n);\n  _va_report(n, \"%s\\0\\n\", arg);\n\tva_end(arg);\n\n\treturn 0;\n}\n\nint main(void) {\n  report(2, \"1\");\n\treturn 0;\n}\n{% endhighlight %}\n#### -> Compile with -Wformat\n<div class=\"noline\" markdown=\"1\">\n{% highlight bash %}\n$ gcc -o format_vprintf format_vprintf.c -Wformat\n\nformat_vprintf.c: In function ‘report’:\nformat_vprintf.c:13:22: warning: embedded ‘\\0’ in format [-Wformat-contains-nul]\n   13 |     _va_report(n, \"%s\\0\\n\", arg);\n      |                      ^~\n{% endhighlight %}\n이 경우에는 format에 대해서만 check 합니다.<br>\n즉 아래와 같은 코드는 검출이 안됩니다.\n#### -> -Wformat-extra-args is not detected\n{% highlight c %}\n#include <stdio.h>\n#include <stdarg.h>\n\n__attribute__((format(printf, 2, 0)))\nint _va_report(int n, const char *fmt, va_list ap) {\n    return vfprintf(stdout, fmt, ap);\n}\n\nint report(int n, ...) {\n\tva_list arg;\n\n\tva_start(arg, n);\n  _va_report(n, \"%s\\n\", arg);\n\tva_end(arg);\n\n\treturn 0;\n}\n\nint main(void) {\n  report(3, \"1\", \"2\", \"3\");\n\treturn 0;\n}\n{% endhighlight %}\n#### -> Compile with -Wformat-extra-args, but not detected\n<div class=\"noline\" markdown=\"1\">\n{% highlight bash %}\n$ gcc -o format_vprintf format_vprintf.c -Wformat -Wformat-extra-args\n...\n{% endhighlight %}\n`strtime`도 마찬가지입니다. `first-to-check`를 0으로 설정해서 사용합니다.\n\n#### -> sample source code: strftime.c\n{% highlight c %}\n#include <stdio.h>\n#include <time.h>\n\n__attribute__((format(strftime, 1, 0)))\nvoid get_time(const char *fmt, struct tm * tptr) {\n    char buf[64];\n\n    strftime(buf, sizeof(buf), fmt, tptr);\n    puts(buf);\n}\n\nint main(void) {\n    time_t tmp;\n    struct tm *tptr;\n\n    tmp = time(NULL);\n    tptr = localtime(&tmp);\n\n    get_time(\"%A, %b %d.\\nTime: %r..%i?\", tptr);\n\n    return 0;\n}\n{% endhighlight %}\n#### -> Compile with -Wformat\n<div class=\"noline\" markdown=\"1\">\n{% highlight bash %}\n$ gcc -o strftime strftime.c -Wformat\n\nstrftime.c: In function ‘main’:\nstrftime.c:19:38: warning: unknown conversion type character ‘i’ in format [-Wformat=]\n   19 |     get_time(\"%A, %b %d.\\nTime: %r..%i?\", tptr);\n      |                                      ^\n{% endhighlight %}\n\n함수 선언에 attribute를 설정해도 됩니다. \n{% highlight c %}\nint report(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n{% endhighlight %}\n이 attribute는 `gcc 2.8.0 release` 때부터 이미 포함되어 있었던 오래된 attribute입니다.\n#### -> gcc 2.8.0 release: c-common.c\n{% highlight c %}\nstatic void\ninit_attributes ()\n{\n  ...\n  add_attribute (A_FORMAT, \"format\", 3, 3, 1);\n  add_attribute (A_FORMAT_ARG, \"format_arg\", 1, 1, 1);\n  ...\n}\n\nvoid\ndecl_attributes (node, attributes, prefix_attributes)\n     tree node, attributes, prefix_attributes;\n{\n  ...\n  case A_FORMAT:\n  {\n    ...\n    if (TREE_CODE (format_type) == IDENTIFIER_NODE\n\t\t&& (!strcmp (IDENTIFIER_POINTER (format_type), \"printf\")\n\t\t    || !strcmp (IDENTIFIER_POINTER (format_type),\n\t\t\t\t\"__printf__\")))\n\t      is_scan = 0;\n\t    else if (TREE_CODE (format_type) == IDENTIFIER_NODE\n\t\t     && (!strcmp (IDENTIFIER_POINTER (format_type), \"scanf\")\n\t\t\t || !strcmp (IDENTIFIER_POINTER (format_type),\n\t\t\t\t     \"__scanf__\")))\n\t      is_scan = 1;\n\t    else if (TREE_CODE (format_type) == IDENTIFIER_NODE)\n\t      {\n\t\terror (\"`%s' is an unrecognized format function type\",\n\t\t       IDENTIFIER_POINTER (format_type));\n\t\tcontinue;\n\t      }\n\t    else\n\t      {\n\t\terror (\"unrecognized format specifier\");\n\t\tcontinue;\n\t      }\n  ...\n}\n{% endhighlight %}\n이 당시에는 archetype이 `printf`와 `scanf` 만 지원됐었습니다.\n\n`strftime`은 `gcc-2.9`에 추가되었습니다.\n#### -> release/gcc-2.95: cat This-change-is-from-an-idea-suggested-by-Arthur-Davi.patch\n{% highlight diff %}\n+\t* c-common.c (decl_attributes, record_function_format,\n+\tcheck_format_info, init_function_format_info):\n+\tAdd support for strftime format checking.\n...\n+\t\tchar *p = IDENTIFIER_POINTER (format_type_id);\n+\t\t\n+\t\tif (!strcmp (p, \"printf\") || !strcmp (p, \"__printf__\"))\n+\t\t  format_type = printf_format_type;\n+\t\telse if (!strcmp (p, \"scanf\") || !strcmp (p, \"__scanf__\"))\n+\t\t  format_type = scanf_format_type;\n+\t\telse if (!strcmp (p, \"strftime\")\n+\t\t\t || !strcmp (p, \"__strftime__\"))\n+\t\t  format_type = strftime_format_type;\n+\t\telse\n+\t\t  {\n+\t\t    error (\"`%s' is an unrecognized format function type\", p);\n+\t\t    continue;\n+\t\t  }\n{% endhighlight %}\n### format_arg\ngcc 코드와 document를 살펴보면 `format_arg`라는 `attribute`도 볼 수 있습니다.<br>\n이 attribute도 `format attribute`와 같은 역할을 합니다.<br>\n다른 점은 `format`만 있는 함수에서 사용합니다.\n예를 들어 다음과 같이 format string에 prefix를 추가하는 함수를 만들 수 있습니다.<br>\n이 경우에는 `format_arg`를 사용하면 됩니다.\n#### -> sample source code: format_arg.c\n{% highlight c %}\n#include <stdio.h>\n\n__attribute__((format_arg(3)))\nchar *debug_format(char *buf, size_t len, char *fmt) {\n    snprintf(buf, len, \"[debug] %s\", fmt);\n\n    return buf;\n}\n\nint main(void) {\n    char buf[32];\n\n    printf(debug_format(buf, sizeof(buf), \"%s\\n\"), \"arg1\", \"excess\");\n\n    return 0;\n}\n{% endhighlight %}\n#### -> Compile with -Wformat\n<div class=\"noline\" markdown=\"1\">\n{% highlight bash %}\n$ gcc -o format_arg format_arg.c -Wformat\n\nformat_arg.c: In function ‘main’:\nformat_arg.c:13:43: warning: too many arguments for format [-Wformat-extra-args]\n   13 |     printf(debug_format(buf, sizeof(buf), \"%s\\n\"), \"arg1\", \"excess\");\n      |                                           ^~~~~~\n{% endhighlight %}\n개인적으로 `-Wformat`은 자칫 run-time에 발생할 수 있는 문제를 compile-time에 미리 알 수 있는 강력한 option이라고 생각합니다.<br>\n그래서 전 코드 작성할 때 가능하면 `-Werror=format`을 추가해 compile error를 발생시키도록 하고 있습니다.<br>\n하지만 사실 코드를 작성하다 보면, 제가 작성한 코드에 대해서 -Wformat 관련 attribute 추가하는 것을 잊어버릴 때가 많이 있습니다.\n\n이럴 때를 위해 gcc는 `-Wmissing-format-attribute`이라는 option도 제공해 줍니다.<br>\n`-Wmissing-format-attribute`에 대해서도 추가 post를 작성할 계획입니다.\n\n결론은 `-Wformat`때와 동일합니다. compile-time에 예측 가능한 문제들을 미리 해결할 수 있도록 `format attribute`를 많이 활용하길 권장 드립니다.\n<div align=\"right\">\njooojub.\n</div>\n"
}