{
 "content": "\n\n#### Requires\n: compiler : gcc 2.7.2 later\n***\n\nC++ has a `constructor` that is called when a class instance is created and a `destructor` that is called when the life-cycle ends.\n\nUnfortunately in c there is no such concept of `constructor` and `destructor` for variables. (However, functions can be hooked using `weak` and `LD_PRELOAD`)\n\nInstead, gcc supports `attributes` that you can specify an executable <mark>constructor</mark> before main and <mark>destructor</mark> after main.\n\n> #### gcc-4.7.0/Function-Attributes<br>\n> <b>constructor</b>\n> <b>destructor</b>\n> <b>constructor (priority)</b>\n> <b>destructor (priority)</b><br>\n> The <b>constructor</b> attribute causes the function to be called automatically before execution enters main ().\n> Similarly, the <b>destructor</b> attribute causes the function to be called automatically after main () has completed or exit () has been called.<br>\n> Functions with these attributes are useful for initializing data that will be used implicitly during the execution of the program.<br>\n> You may provide an optional integer priority to control the order in which <mark>constructor</mark> and <mark>destructor</mark> functions are run.<br>\n> A constructor with a smaller priority number runs before a `constructor` with a larger priority number; the opposite relationship holds for `destructors`.<br>\n> So, if you have a `constructor` that allocates a resource and a `destructor` that deallocates the same resource, both functions typically have the same priority.<br>\n> The priorities for `constructor` and `destructor` functions are the same as those specified for namespace-scope C++ objects<br>\n> **ref:&nbsp;**<a target=\"_blank\" href=\"https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Function-Attributes.html\"><code>https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Function-Attributes.html</code></a></cite>\n\nIt's simple to use.\n\n```c\n: sampe source code - usage.c\n#include <stdio.h>\n\n__attribute__((constructor))\nvoid ctor_func() {\n\tprintf(\"-> before main\\n\");\t\n}\n\n__attribute__((destructor))\nvoid dtors_func() {\n\tprintf(\"<- after main\\n\");\t\n}\n\nint main(void) {\n\tprintf(\"main\\n\");\n\n\treturn 0;\n}\n```\n```bash\n: compile\n$ gcc -o usage usage.c\n$ ./usage\n```\n```bash\n: output\n-> before main\nmain\n<- after main\n```\nYou can see that `ctor_func` defined with <mark>__attribute__((constructor))</mark> is called first, and `dtors_func` defined with <mark>__attribute__((destructor))</mark> is called after main.\n\nWe need to look at how `constructor` and `destructor` are called.\n\nFirst, let's see how gcc manages and calls it.\n\nPrior to gcc 4.7, `constructors` was managed using <b>.ctors</b> section of ELF and `destructors` was managed using <b>.dtors</b> section.\n\nOn the other hand, after gcc 4.7, <b>TARGET_ASM_CONSTRUCTOR</b> is defined as <b>default_elf_init_array_asm_out_constructor</b> and it calls <b>get_elf_initfini_array_priority_section</b> and stores the functions in `.init_array` secion and `.fini_array` of ELF.\n\nLet's look at the calling process. Let's check it based on `.init_array`.\nLooking at the start address of the previously generated sample code.\n\n```bash\n: check start address\n$ objdump -f usage\n```\n```bash\n: output\nusage:     file format elf64-x86-64\narchitecture: i386:x86-64, flags 0x00000150:\nHAS_SYMS, DYNAMIC, D_PAGED\nstart address 0x0000000000001060\n```\n\nWe can check the start address.\nThis value is the e_entry value of the <b>ELF header</b>.\n\nIf you look at the function at the start address value with objdump, you can see that it is the <b>_start</b> function.\n\n```x86asm\n: The starting position of ELF is\n$ objdump -d usage | grep -A15 0000000000001060\n0000000000001060 <_start>:\n    1060:\tf3 0f 1e fa          \tendbr64 \n    1064:\t31 ed                \txor    %ebp,%ebp\n    1066:\t49 89 d1             \tmov    %rdx,%r9\n    1069:\t5e                   \tpop    %rsi\n    106a:\t48 89 e2             \tmov    %rsp,%rdx\n    106d:\t48 83 e4 f0          \tand    $0xfffffffffffffff0,%rsp\n    1071:\t50                   \tpush   %rax\n    1072:\t54                   \tpush   %rsp\n    1073:\t4c 8d 05 96 01 00 00 \tlea    0x196(%rip),%r8        # 1210 <__libc_csu_fini>\n    107a:\t48 8d 0d 1f 01 00 00 \tlea    0x11f(%rip),%rcx        # 11a0 <__libc_csu_init>\n    1081:\t48 8d 3d ef 00 00 00 \tlea    0xef(%rip),%rdi        # 1177 <main>\n    1088:\tff 15 52 2f 00 00    \tcallq  *0x2f52(%rip)        # 3fe0 <__libc_start_main@GLIBC_2.2.5>\n    108e:\tf4                   \thlt    \n    108f:\t90                   \tnop\n```\n\nLooking at the `_start` function, Store the function addresses of  `__libc_csu_init`, `__libc_csu_fini` and `main` and call <mark>_libc_start_main</mark>\n\n<mark>__libc_start_main</mark> is a csu (C start up) or crt (C runtime) routine processed by `glibc` before calling ELF's main.\n\nFor reference, you can see the link process by using the -v option when building gcc.\n```bash\n: Check link process\n$ gcc -v constructor.c\n\n /usr/lib/gcc/x86_64-linux-gnu/9/collect2 \n -plugin /usr/lib/gcc/x86_64-linux-gnu/9/liblto_plugin.so\n -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper \n -plugin-opt=-fresolution=/tmp/ccSPNgPY.res \n -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s \n -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc \n -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m \n elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker \n /lib64/ld-linux-x86-64.so.2 \n -pie -z now -z relro\n /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o\n /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crti.o\n /usr/lib/gcc/x86_64-linux-gnu/9/crtbeginS.o\n -L/usr/lib/gcc/x86_64-linux-gnu/9\n -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu\n -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib\n -L/lib/x86_64-linux-gnu\n -L/lib/../lib\n -L/usr/lib/x86_64-linux-gnu\n -L/usr/lib/../lib\n -L/usr/lib/gcc/x86_64-linux-gnu/9/../../..\n /tmp/cclu3MJY.o -lgcc --push-state --as-needed -lgcc_s\n --pop-state -lc -lgcc --push-state --as-needed -lgcc_s\n --pop-state /usr/lib/gcc/x86_64-linux-gnu/9/crtendS.o\n /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crtn.o\n```\n<mark>crt*.o</mark> in sysroot are used in startup routine.\n\n<mark>call_init()</mark> and <mark>call_fini()</mark> are called in `LIBC_START_MAIN` in glibc.\n<b>call_init()</b> calls <mark>__init_array_start</mark> and <b>call_fini()</b> calls <mark>__fini_array_start</mark>.\n\n```c\n: check libc-start.c in glibc\nstatic void\ncall_init (int argc, char **argv, char **envp) {\n...\n  const size_t size = __init_array_end - __init_array_start;\n  for (size_t i = 0; i < size; i++)\n      (*__init_array_start [i]) (argc, argv, envp);\n...\n}\n...\n\nstatic void\ncall_fini (void *unused)\n{\n  size_t i = __fini_array_end - __fini_array_start;\n  while (i-- > 0)\n    (*__fini_array_start [i]) ();\n...\n}\n```\nNow we need to look at which functions are registered in <mark>init_array</mark> and <mark>fini_array</mark>.\n\nLooking at the ELF dynamic section of the sample program, there are `INIT_ARRAY/FINI_ARRAY` and `INIT_ARRAYSZ/FINI_ARRAYSZ`.\n\n```bash\n: Check ELF dynamic section\n$ readelf -d ./usage\n...\n 0x0000000000000019 (INIT_ARRAY)         0x3da8\n 0x000000000000001b (INIT_ARRAYSZ)       16 (bytes)\n 0x000000000000001a (FINI_ARRAY)         0x3db8\n 0x000000000000001c (FINI_ARRAYSZ)       16 (bytes)\n...\n```\nLet's print <mark>INIT_ARRAY</mark> as much as <mark>INIT_ARRAYSZ</mark> using gdb.\n\n```bash\n: what's in INIT_ARRAY\n(gdb) x/2g 0x3da8\n0x3da8:\t0x0000000000001140\t0x0000000000001149\n\n(gdb) disassemble 0x0000000000001140\nDump of assembler code for function frame_dummy:\n   0x0000000000001140 <+0>:\tendbr64 \n   0x0000000000001144 <+4>:\tjmpq   0x10c0 <register_tm_clones>\nEnd of assembler dump.\n\n(gdb) disassemble 0x0000000000001149\nDump of assembler code for function ctor_func:\n   0x0000000000001149 <+0>:\tendbr64 \n   0x000000000000114d <+4>:\tpush   %rbp\n   0x000000000000114e <+5>:\tmov    %rsp,%rbp\n   0x0000000000001151 <+8>:\tlea    0xeac(%rip),%rdi        # 0x2004\n   0x0000000000001158 <+15>:\tcallq  0x1050 <puts@plt>\n   0x000000000000115d <+20>:\tnop\n   0x000000000000115e <+21>:\tpop    %rbp\n   0x000000000000115f <+22>:\tretq   \nEnd of assembler dump.\n```\n\n`ctor_func` function address is in <mark>INIT_ARRAY</mark>.\n\nThe same goes for <mark>FINI_ARRAY</mark>.\n\n```bash\n: what's in FINI_ARRAY\n(gdb) x/2g 0x3db8\n0x3db8:\t0x0000000000001100\t0x0000000000001160\n(gdb) disassemble 0x0000000000001100\nDump of assembler code for function __do_global_dtors_aux:\n   0x0000000000001100 <+0>:\tendbr64 \n   0x0000000000001104 <+4>:\tcmpb   $0x0,0x2f05(%rip)        # 0x4010 <completed.8059>\n   0x000000000000110b <+11>:\tjne    0x1138 <__do_global_dtors_aux+56>\n   0x000000000000110d <+13>:\tpush   %rbp\n   0x000000000000110e <+14>:\tcmpq   $0x0,0x2ee2(%rip)        # 0x3ff8\n   0x0000000000001116 <+22>:\tmov    %rsp,%rbp\n   0x0000000000001119 <+25>:\tje     0x1127 <__do_global_dtors_aux+39>\n   0x000000000000111b <+27>:\tmov    0x2ee6(%rip),%rdi        # 0x4008\n   0x0000000000001122 <+34>:\tcallq  0x1040 <__cxa_finalize@plt>\n   0x0000000000001127 <+39>:\tcallq  0x1090 <deregister_tm_clones>\n   0x000000000000112c <+44>:\tmovb   $0x1,0x2edd(%rip)        # 0x4010 <completed.8059>\n   0x0000000000001133 <+51>:\tpop    %rbp\n   0x0000000000001134 <+52>:\tretq   \n   0x0000000000001135 <+53>:\tnopl   (%rax)\n   0x0000000000001138 <+56>:\tretq   \n   0x0000000000001139 <+57>:\tnopl   0x0(%rax)\nEnd of assembler dump.\n(gdb) disassemble 0x0000000000001160\n\nDump of assembler code for function dtors_func:\n   0x0000000000001160 <+0>:\tendbr64 \n   0x0000000000001164 <+4>:\tpush   %rbp\n   0x0000000000001165 <+5>:\tmov    %rsp,%rbp\n   0x0000000000001168 <+8>:\tlea    0xea4(%rip),%rdi        # 0x2013\n   0x000000000000116f <+15>:\tcallq  0x1050 <puts@plt>\n   0x0000000000001174 <+20>:\tnop\n   0x0000000000001175 <+21>:\tpop    %rbp\n   0x0000000000001176 <+22>:\tretq   \nEnd of assembler dump.\n```\nManaging as an array means that <b>multiple functions</b> can be registered.\nIt also means you can set `priorities`.\n\n```c\n: Also support priority\n#include <stdio.h>\n\n__attribute__((constructor(101)))\nvoid constructor_101() {\n\tprintf(\"-> constructor priority 101\\n\");\t\n}\n\n__attribute__((constructor(102)))\nvoid constructor_102() {\n\tprintf(\"-> constructor priority 102\\n\");\t\n}\n\n__attribute__((destructor(101)))\nvoid destructor_101() {\n\tprintf(\"<- descriptor priority 101\\n\");\t\n}\n\n__attribute__((destructor(102)))\nvoid destructor_102() {\n\tprintf(\"<- descriptor priority 102\\n\");\t\n}\n\nint main(void) {\n\tprintf(\"main\\n\");\n\treturn 0;\n}\n```\n```bash\n: result\ngcc -o ctor_pri ctor_pri.c\n./ctor_pri\n\n-> constructor priority 101\n-> constructor priority 102\nmain\n<- descriptor priority 102\n<- descriptor priority 101\n```\n\nIn the case of constructors, the smaller the value, the faster it is called.\non the contrary, In the case of the destructor the higher the value, the faster it is called. (Available from 101)\n\nSo what if the priorities are the same?\n```c\n: how are the same priorities handled?\n#include <stdio.h>\n\n__attribute__((constructor(101)))\nvoid ctor_func_1() {\n\tprintf(\"-> constructor priority 101\\n\");\t\n}\n\n__attribute__((constructor(101)))\nvoid ctor_func_2() {\n\tprintf(\"-> me too constructor priority 101\\n\");\t\n}\n\n__attribute__((destructor(101)))\nvoid dtors_func_1() {\n\tprintf(\"<- descriptor priority 101\\n\");\t\n}\n\n__attribute__((destructor(101)))\nvoid dtors_func_2() {\n\tprintf(\"<- me too descriptor priority 101\\n\");\t\n}\n\nint main(void) {\n\tprintf(\"main\\n\");\n\treturn 0;\n}\n```\n```bash\n: result\ngcc -o ctor_pri_same ctor_pri_same.c\n./ctor_pri_same\n\n-> constructor priority 101\n-> me too constructor priority 101\nmain\n<- me too descriptor priority 101\n<- descriptor priority 101\n```\n\nIf the priority is the same, it appears to be a structure that enters the array in the order parsed by the compiler and executes them sequentially.\nThe destructor will be called in reverse, right?\n\nEven in scenarios where it is terminated by a combination of signal handler and exit rather than normal termination\nLet's make sure the destructor is called.\n\n```c\n: does it work in signal handler too?\n#include <stdio.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid sig_handler(int signo) {\n\tif (signo == SIGINT) {\n\t\tprintf(\"received SIGINT\\n\");\n\n\t\texit(0);\n\t}\n}\n\n__attribute__((constructor))\nvoid ctor_func() {\n\tprintf(\"-> before main\\n\");\t\n}\n\n__attribute__((destructor))\nvoid dtors_func() {\n\tprintf(\"<- after main\\n\");\t\n}\n\nint main(void) {\n\tsignal(SIGINT, sig_handler);\n\n\tprintf(\"main\\n\");\n\n\twhile (1) {}\n\n\treturn 0;\n}\n```\n\nThis attribute comes into its own when used with the dynamic library.\n\nWe can add something before main without rebuilding the already compiled process.\n\n```c\n: add constructor / descriptor in shared library for preload\n#include <stdio.h>\n\n__attribute__((constructor))\nvoid ctor() {\n\tprintf(\"hook lib constructor!\\n\");\n}\n\n__attribute__((destructor))\nvoid dtors() {\n\tprintf(\"hook lib destructor!\\n\");\n}\n```\n```bash\ngcc -shared -o hooklib.so hooklib.c\n\nLD_PRELOAD=`pwd`/hooklib.so ./pre-compiled\n\nhook lib constructor!\nmain\nhook lib destructor!\n```\nOf course, it can also be used in the dynamic library you are using.\n\n```c\n: add constructor / descriptor in shared library: hooklib.c\n#include <stdio.h>\n\nvoid foo(void) {\n\tprintf(\"I'm foo!\\n\");\n}\n\n__attribute__((constructor))\nvoid ctor() {\n\tprintf(\"hook lib constructor!\\n\");\n}\n\n__attribute__((destructor))\nvoid dtors() {\n\tprintf(\"hook lib destructor!\\n\");\n}\n```\n```c\n: add constructor / descriptor in shared library: sample.c \n#include <stdio.h>\n\nint main(void) {\n\tprintf(\"I'm main\\n\");\n\n\tfoo();\n\treturn 0;\n}\n```\n```bash\ngcc -shared -o hooklib.so hooklib.c\ngcc -o sample sample.c ./hooklib.so\n\ngcc -o sample sample.c ./hooklib.so\n\n./sample\nhook lib constructor!\nI'm main\nI'm foo!\nhook lib destructor!\n```\nThere are many utilize ways to use it\n\nYou can create a hooking library for debugging already built binaries.\nand also can prevent leaks by alloc/free of global variables."
}