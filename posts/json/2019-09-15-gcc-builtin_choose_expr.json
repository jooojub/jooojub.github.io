{
 "content": "\n\nRequires:\n * compiler: gcc 3.1 later\n\n이번은 gcc builtin 중 `__builtin_choose_expr`에 대해서 살펴봅시다.<br>\n이 built-in function은 C++에는 없고 C에만 존재합니다.<br>\n\n마치 C의 3-way operator(? : operator)처럼 동작합니다.<br>\n그러나 run-time이 아니라 compile-time에 동작한다는 것을 명심해야 합니다.\n\n이 built-in은 gcc-3.1에 'Aldy Hernandez' patch를 통해 추가되었습니다.\n\ngcc 문서의 설명을 확인해보겠습니다.\n\n***\n<table>\n    <thead>\n        <tr>\n            <th>Built-in Function: type __builtin_choose_expr (const_exp, exp1, exp2)</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n\t\t\t\tYou can use the built-in function <b>__builtin_choose_expr</b> to evaluate code depending on the value of a constant expression. This built-in function returns exp1 if const_exp, which is an integer constant expression, is nonzero. Otherwise it returns exp2.<br><br>\n\t\t\t\tThis built-in function is analogous to the ‘? :’ operator in C, except that the expression returned has its <b>type unaltered by promotion rules</b>. Also, the built-in function does not evaluate the expression that is not chosen. For example, if const_exp evaluates to true, exp2 is not evaluated even if it has side effects...<br><br>\n                <cite>ref. <a href=\"https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/Other-Builtins.html#Other-Builtins\"><code>https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/Other-Builtins.html#Other-Builtins</code></a></cite>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n***\n\ngcc code를 살펴보면 이 builtin function이 어떻게 동작하는지에 대해 쉽게 이해하실 수 있을 겁니다.<br>\ngcc 7.4의 코드를 살펴보겠습니다.\n\n#### -> git checkout gcc-7_4_0-release\n{% highlight c %}\n$ cat ./gcc/c/c-parser.c\n\n\t...\n\tcase RID_CHOOSE_EXPR:\n\t  {\n\t    ...\n\t    e1_p = &(*cexpr_list)[0];\n\t    e2_p = &(*cexpr_list)[1];\n\t    e3_p = &(*cexpr_list)[2];\n\n\t    c = e1_p->value;\n\t    mark_exp_read (e2_p->value);\n\t    mark_exp_read (e3_p->value);\n\t    if (TREE_CODE (c) != INTEGER_CST\n\t\t|| !INTEGRAL_TYPE_P (TREE_TYPE (c)))\n\t      error_at (loc,\n\t\t\t\"first argument to %<__builtin_choose_expr%> not\"\n\t\t\t\" a constant\");\n\t    constant_expression_warning (c);\n\t    expr = integer_zerop (c) ? *e3_p : *e2_p;\n\t    set_c_expr_source_range (&expr, loc, close_paren_loc);\n\t\t...\n{% endhighlight %}\n\n코드들 자세히 보시면 3-way ooperator로 구현이 되었다는 것을 보실 수 있습니다.\n\n{% highlight c %}\nexpr = integer_zerop (c) ? *e3_p : *e2_p;\n-> \n\tconst_exp ? exp1 : exp2\n{% endhighlight %}\n\n> Don't confuse gcc builtin as a function called at compile time\n\n첫 번째 argument는 `const_exp` 이어야 합니다.<br>\n다시 말해, variable이 compile time에 정해진다고 해도 argument로 사용할 수 없다는 뜻입니다.<br>\n\n#### -> can we use the variables for the first argument?\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n\tconst int cond = 1;\n\tchar *boolean = __builtin_choose_expr(cond, \"true\", \"false\");\n\n\tprintf(\"boolean: %s\\n\", boolean);\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> gcc version 7.4.0 –target=x86_64-linux-gnu\n{% highlight bash %}\n$ gcc -o cond_expr cond_expr.c\n\ncond_expr.c: In function ‘main’:\ncond_expr.c:5:18: error: first argument to ‘__builtin_choose_expr’ not a constant\n  char *boolean = __builtin_choose_expr(cond, \"true\", \"false\");\n{% endhighlight %}\n\ncompile error가 발생하는걸 볼 수 있습니다.<br>\n즉, 다음과 같이 `const expr`만 사용할 수 있습니다.\n\n#### -> use const expr for the first argument\n{% highlight c %}\n#define BOOL_TO_STR(__x) \\\n\t__builtin_choose_expr(((__x)), \"true\", \"false\")\n\nint main(void) {\n\tprintf(\"%s\\n\", BOOL_TO_STR(0));\n\tprintf(\"%s\\n\", BOOL_TO_STR(1));\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> gcc version 7.4.0 –target=x86_64-linux-gnu\n{% highlight bash %}\n$ gcc -o bool_to_str bool_to_str.c\n$ ./bool_to_str\n\nfalse\ntrue\n{% endhighlight %}\n#### -> assembly: x86_64 AT&T\n{% highlight x86asm %}\nint main(void) {\n  400526:       55                      push   %rbp\n  400527:       48 89 e5                mov    %rsp,%rbp\n        printf(\"%s\\n\", BOOL_TO_STR(0));\n  40052a:       bf d4 05 40 00          mov    $0x4005d4,%edi\n  40052f:       e8 cc fe ff ff          callq  400400 <puts@plt>\n        printf(\"%s\\n\", BOOL_TO_STR(1));\n  400534:       bf da 05 40 00          mov    $0x4005da,%edi\n  400539:       e8 c2 fe ff ff          callq  400400 <puts@plt>\n\n        return 0;\n  40053e:       b8 00 00 00 00          mov    $0x0,%eax\n}\n  400543:       5d                      pop    %rbp\n  400544:       c3                      retq   \n  400545:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)\n  40054c:       00 00 00 \n  40054f:       90                      nop\n{% endhighlight %}\n{% highlight bash %}\n$ strings -t x bool_to_str\n...\n    5d4 false\n    5da true\n{% endhighlight %}\n`__builtin_choose_expr`가 compile-time에 각각 `exp1` 또는 `exp2`로 변환 된 것을 볼 수 있습니다.\n\n`const exp`만 사용할 수 있기 때문에, 불필요한 builtin function 아닌가 생각할 수도 있습니다.\n\n그러나, 의외로 많은 활용을 할 수 있습니다.\n\n예를 들어, 특정 bit가 설정되어 있는지 compile time에 확인하는 IS_MASKED macro를 다음과 같이 작성할 수 있습니다.\n\n#### -> e.g. masked\n{% highlight c %}\n#define IS_MASKED(__value) \\\n\t__builtin_choose_expr(((__value) & 0x1), 1, 0)\n\nint main(void) {\n\tprintf(\"masked: %d\\n\", IS_MASKED(0xff));\n\tprintf(\"masked: %d\\n\", IS_MASKED(0x02));\n\tprintf(\"masked: %d\\n\", IS_MASKED(0x03));\n}\n{% endhighlight %}\n#### -> gcc version 7.4.0 –target=x86_64-linux-gnu\n{% highlight bash %}\n$ gcc -o masked masked.c\n$ ./masked\n\nmasked: 1\nmasked: 0\nmasked: 1\n{% endhighlight %}\nsizeof와 같이 활용할 수도 있습니다.<br>\nKernel에서 eBPF code를 살펴보면, 아래와 같이 sizeof와 같이 활용한 예가 있습니다.\n#### -> e.g. sizeof in BPF\n{% highlight c %}\n$ cat ./include/trace/bpf_probe.h\n\n/* cast any integer, pointer, or small struct to u64 */\n#define UINTTYPE(size) \\\n\t__typeof__(__builtin_choose_expr(size == 1,  (u8)1, \\\n\t\t   __builtin_choose_expr(size == 2, (u16)2, \\\n\t\t   __builtin_choose_expr(size == 4, (u32)3, \\\n\t\t   __builtin_choose_expr(size == 8, (u64)4, \\\n\t\t\t\t\t (void)5)))))\n#define __CAST_TO_U64(x) ({ \\\n\ttypeof(x) __src = (x); \\\n\tUINTTYPE(sizeof(x)) __dst; \\\n\tmemcpy(&__dst, &__src, sizeof(__dst)); \\\n\t(u64)__dst; })\n}\n{% endhighlight %}\n\n***\n\n이 builtin function 3-way operator와는 약간 다른 차이점이 있습니다.\n\n3-way operator는 더욱 사이즈가 큰 type으로 `type cast` 되어 return 되지만, `builtin function`은 `exp1` 또는 `exp2` 각자의 `type`이 return 됩니다.\n\n#### -> check return type\n{% highlight c %}\n#include <stdio.h>\n\n#define RET_TYPE(__x) \\\n\t__builtin_choose_expr((__x), ret_int(), ret_char())\n\nint ret_int(void) {\n\treturn 1;\n}\n\nchar ret_char(void) {\n\treturn 'a';\n}\n\nint main(void) {\n\t/* return char */\n\tprintf(\"sizeof: %lu\\n\", sizeof(RET_TYPE(0)));\n\t/* return int */\n\tprintf(\"sizeof: %lu\\n\", sizeof(RET_TYPE(1)));\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> gcc version 7.4.0 –target=x86_64-linux-gnu\n{% highlight bash %}\n$ gcc -o return_type return_type.c\n\n./return_type\nsizeof: 1\nsizeof: 4\n{% endhighlight %}\n`__builtin_types_compatible_p`와 같이 사용하면 더욱 멋진 활용이 가능합니다만, 다음 post를 위해 아껴두겠습니다. :)<br>\n\n`__builtin_choose_expr`은 const expr를 return 하는 다른 build-in function과 조합해서 많이 사용합니다.<br>\n예를 들어 `__builtin_types_compatible_p`와 조합하면 C에서 불가능해만 보였던 `type-arguments`을 위한 `function overloading` 구현도 가능합니다.\n\n#### -> functon overloading \n{% highlight c %}\n#include <stdio.h>\n\n#define debug(var)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tprintf(\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t__builtin_choose_expr( \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__builtin_types_compatible_p(typeof(var), int) \t\t\t\t\\\n\t\t\t,\"%d\\n\", __builtin_choose_expr(\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t__builtin_types_compatible_p(typeof(var), char []) \t\\\n\t\t\t\t,\"%s\\n\", \"0x%x\\n\")), var);\n\nint main(void) {\n\tdebug(1234);\n\tdebug(\"jooojub\");\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> gcc version 7.4.0 –target=x86_64-linux-gnu\n{% highlight bash %}\n$ gcc -o function_overloading function_overloading.c \n$ ./function_overloading\n\n1234\njooojub\n{% endhighlight %}\n\n`__builtin_types_compatible_p`에 대해서는 다른 post에서 다루겠습니다.\n> 또한 standard C에서도 macro를 이용해 `number of arguments`를 구현할 수 있습니다. 기회가 된다면 이 또한 다른 post에서 다루겠습니다.\n\n`__builtin_choose_expr`는 쉽게 단순해서 이해하기 쉽지만, 유용하게 사용한다면 불필요한 코드를 줄일 수 있으므로, 많이 활용하길 바랍니다.\n\n<div align=\"right\">\njooojub.\n</div>"
}