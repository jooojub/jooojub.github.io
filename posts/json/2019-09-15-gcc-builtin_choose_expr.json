{
 "content": "\n\n#### Requires\n: compiler : gcc 3.1 later\n***\n\nThis time, let's take a look at <mark>__builtin_choose_expr</mark> among gcc builtin.\nThis built-in function does not exist in C++, it exists only in C.\n\nIt behaves like a C's 3-way operator`(? : operator)`.\nHowever, it should be borne in mind that this works at <mark>compile-time</mark>, not run-time.\n\nThis built-in was added to gcc-3.1 through the 'Aldy Hernandez' patch.\n\nLet's check the explanation in the gcc documentation.\n\n> #### __builtin_choose_expr (const_exp, exp1, exp2)\n> You can use the built-in function <b>__builtin_choose_expr</b> to evaluate code depending on the value of a constant expression.\nThis built-in function returns exp1 if const_exp, which is an integer constant expression, is nonzero. Otherwise it returns exp2.<br>\nThis built-in function is analogous to the ‘? :’ operator in C, except that the expression returned has its <b>type unaltered by promotion rules</b>.\nAlso, the built-in function does not evaluate the expression that is not chosen.\nFor example, if const_exp evaluates to true, exp2 is not evaluated even if it has side effects...<br>\n> **ref:&nbsp;**<a target=\"_blank\" href=\"https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/Other-Builtins.html#Other-Builtins\"><code>https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/Other-Builtins.html#Other-Builtins</code></a></cite>\n\nWe can easily understand how this builtin function works by looking at the gcc code.\nLet's look at the code from gcc 7.4.\n\n```c\n: git checkout gcc-7_4_0-release\n$ cat ./gcc/c/c-parser.c\n\n\t...\n\tcase RID_CHOOSE_EXPR:\n\t  {\n\t    ...\n\t    e1_p = &(*cexpr_list)[0];\n\t    e2_p = &(*cexpr_list)[1];\n\t    e3_p = &(*cexpr_list)[2];\n\n\t    c = e1_p->value;\n\t    mark_exp_read (e2_p->value);\n\t    mark_exp_read (e3_p->value);\n\t    if (TREE_CODE (c) != INTEGER_CST\n\t\t|| !INTEGRAL_TYPE_P (TREE_TYPE (c)))\n\t      error_at (loc,\n\t\t\t\"first argument to %<__builtin_choose_expr%> not\"\n\t\t\t\" a constant\");\n\t    constant_expression_warning (c);\n\t    expr = integer_zerop (c) ? *e3_p : *e2_p;\n\t    set_c_expr_source_range (&expr, loc, close_paren_loc);\n\t\t...\n```\nIf you look closely at the codes, you can see that it is implemented as a 3-way ooperator.\n\n```c\nexpr = integer_zerop (c) ? *e3_p : *e2_p;\n-> const_exp ? exp1 : exp2\n```\n\n> Don't confuse gcc builtin as a function called at compile time\n\nThe first argument must be <mark>const_exp</mark>.\nIn other words, even if a variable is set at compile time, it cannot be used as an argument.\n\n```c\n: can we use the variables for the first argument?\n#include <stdio.h>\n\nint main(void) {\n\tconst int cond = 1;\n\tchar *boolean = __builtin_choose_expr(cond, \"true\", \"false\");\n\n\tprintf(\"boolean: %s\\n\", boolean);\n\n\treturn 0;\n}\n```\n```bash\n: gcc version 7.4.0 –target=x86_64-linux-gnu\n$ gcc -o cond_expr cond_expr.c\n\ncond_expr.c: In function ‘main’:\ncond_expr.c:5:18: error: first argument to ‘__builtin_choose_expr’ not a constant\n  char *boolean = __builtin_choose_expr(cond, \"true\", \"false\");\n```\nWe can see that a compile error occurs.\n\nThat is, you can only use `const expr` like this:\n\n```c\n: use const expr for the first argument\n#define BOOL_TO_STR(__x) \\\n\t__builtin_choose_expr(((__x)), \"true\", \"false\")\n\nint main(void) {\n\tprintf(\"%s\\n\", BOOL_TO_STR(0));\n\tprintf(\"%s\\n\", BOOL_TO_STR(1));\n\n\treturn 0;\n}\n```\n```bash\n: gcc version 7.4.0 –target=x86_64-linux-gnu\n$ gcc -o bool_to_str bool_to_str.c\n$ ./bool_to_str\n\nfalse\ntrue\n```\n```x86asm\n: assembly - x86_64 AT&T\nint main(void) {\n  400526:       55                      push   %rbp\n  400527:       48 89 e5                mov    %rsp,%rbp\n        printf(\"%s\\n\", BOOL_TO_STR(0));\n  40052a:       bf d4 05 40 00          mov    $0x4005d4,%edi\n  40052f:       e8 cc fe ff ff          callq  400400 <puts@plt>\n        printf(\"%s\\n\", BOOL_TO_STR(1));\n  400534:       bf da 05 40 00          mov    $0x4005da,%edi\n  400539:       e8 c2 fe ff ff          callq  400400 <puts@plt>\n\n        return 0;\n  40053e:       b8 00 00 00 00          mov    $0x0,%eax\n}\n  400543:       5d                      pop    %rbp\n  400544:       c3                      retq   \n  400545:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)\n  40054c:       00 00 00 \n  40054f:       90                      nop\n```\n```bash\n$ strings -t x bool_to_str\n...\n    5d4 false\n    5da true\n```\n\nYou can see that <mark>__builtin_choose_expr</mark> is converted to `exp1` or `exp2` respectively at compile-time.\n\nSince only `constant exp` can be used, you may think that it is an unnecessary build-in function.\n\nHowever, it can be surprisingly useful.\n\nFor example, the `IS_MASKED macro` that checks whether a specific bit is set at compile time can be written as follows.\n\n```c\n: e.g. masked\n#define IS_MASKED(__value) \\\n\t__builtin_choose_expr(((__value) & 0x1), 1, 0)\n\nint main(void) {\n\tprintf(\"masked: %d\\n\", IS_MASKED(0xff));\n\tprintf(\"masked: %d\\n\", IS_MASKED(0x02));\n\tprintf(\"masked: %d\\n\", IS_MASKED(0x03));\n}\n```\n```bash\n: gcc version 7.4.0 –target=x86_64-linux-gnu\n$ gcc -o masked masked.c\n$ ./masked\n\nmasked: 1\nmasked: 0\nmasked: 1\n```\nIt can also be used with `sizeof`.\nLooking at the `eBPF` code in the kernel, there is an example of using sizeof as shown below.\n```c\n: e.g. sizeof in BPF\n$ cat ./include/trace/bpf_probe.h\n\n/* cast any integer, pointer, or small struct to u64 */\n#define UINTTYPE(size) \\\n\t__typeof__(__builtin_choose_expr(size == 1,  (u8)1, \\\n\t\t   __builtin_choose_expr(size == 2, (u16)2, \\\n\t\t   __builtin_choose_expr(size == 4, (u32)3, \\\n\t\t   __builtin_choose_expr(size == 8, (u64)4, \\\n\t\t\t\t\t (void)5)))))\n#define __CAST_TO_U64(x) ({ \\\n\ttypeof(x) __src = (x); \\\n\tUINTTYPE(sizeof(x)) __dst; \\\n\tmemcpy(&__dst, &__src, sizeof(__dst)); \\\n\t(u64)__dst; })\n}\n```\nThis `builtin` differs slightly from the 3-way operator.\n\nThe 3-way operator returns a `type cast` to a larger type, whereas the <mark>builtin function</mark> returns a `type` of either `exp1` or `exp2`.\n\n```c\n: check return type\n#include <stdio.h>\n\n#define RET_TYPE(__x) \\\n\t__builtin_choose_expr((__x), ret_int(), ret_char())\n\nint ret_int(void) {\n\treturn 1;\n}\n\nchar ret_char(void) {\n\treturn 'a';\n}\n\nint main(void) {\n\t/* return char */\n\tprintf(\"sizeof: %lu\\n\", sizeof(RET_TYPE(0)));\n\t/* return int */\n\tprintf(\"sizeof: %lu\\n\", sizeof(RET_TYPE(1)));\n\n\treturn 0;\n}\n```\n```bash\n: gcc version 7.4.0 –target=x86_64-linux-gnu\n$ gcc -o return_type return_type.c\n\n./return_type\nsizeof: 1\nsizeof: 4\n```\nIt can be used more nicely with <mark>__builtin_types_compatible_p</mark>, but I will save it for the next post. :)\n\n<mark>__builtin_choose_expr</mark> is often used in combination with other build-in functions that return `const expr`.\n\nFor example, Combined with <mark>__builtin_types_compatible_p</mark>,\nit is possible to implement `function overloading` for `type-arguments` which seemed impossible in C.\n\n```c\n: functon overloading in c \n#include <stdio.h>\n\n#define debug(var) \\\n\tprintf(\t\t\t\\\n\t\t__builtin_choose_expr( \t\\\n\t\t\t__builtin_types_compatible_p(typeof(var), int) \t\\\n\t\t\t,\"%d\\n\", __builtin_choose_expr(\t\t\t\t\t\\\n\t\t\t\t__builtin_types_compatible_p(typeof(var), char []) \t\\\n\t\t\t\t,\"%s\\n\", \"0x%x\\n\")), var);\n\nint main(void) {\n\tdebug(1234);\n\tdebug(\"jooojub\");\n\n\treturn 0;\n}\n```\n```bash\n: gcc version 7.4.0 –target=x86_64-linux-gnu\n$ gcc -o function_overloading function_overloading.c \n$ ./function_overloading\n\n1234\njooojub\n```\n<mark>__builtin_types_compatible_p</mark> will be covered in another post.\n> Also in standard C, you can implement `number of arguments` using macros.\n> If I get a chance, I'll cover this in another post as well.\n\n<mark>__builtin_choose_expr</mark> is simple and easy to understand, but if used usefully, it can reduce unnecessary code, so please use it a lot."
}