{
 "content": "\n\n#### Environmets\n : compiler: x86_64-linux-gnu 7.4.0, x86_64-linux-gnu 4.8.5\n : assembly: AT&T\n : code base: glibc 2.23.90\n\n**All content is written based on GNU C.**\n***\n\nAs you know <mark>NULL</mark> and <mark>0</mark> are not equal in GNU C\n> NULL != 0\n\nSo what is <mark>NULL</mark>? Let's check it easily with a simple sample code.\n\n```c\n: sample source code - null.c\n#include <stddef.h>\n\nint main(void) {\n\tchar *value = NULL;\n\n\treturn 0;\n}\n```\n```bash\n: preprocess only\n$ gcc -E null.c\n```\n```c\n: result\n# 1 \"null.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 31 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 32 \"<command-line>\" 2\n# 1 \"null.c\"\n# 1 \"/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h\" 1 3 4\n.....\n\n# 3 \"null.c\"\nint main(void) {\n char *value = \n# 4 \"null.c\" 3 4\n\t((void *)0) /* 0 == ((void *)0) */\n...\n}\n```\n\nAs you can see from the result of the pre-process, <mark>NULL</mark> is replaced with <mark>((void *)0)</mark>.\n> NULL == ((void *)0)\n\nSo what about including <cd>stdio.h</cd> instead of <cd>stddef.h</cd>?\n\n```c\n: include `stdio.h` instead of `stddef.h`\n#include <stdio.h>\n\nint main(void) {\n\tchar *value = NULL;\n\n\treturn 0;\n}\n```\n```bash\n: preprocess only\n$ gcc -E null.c\n```\n```c\n:result\n# 4 \"null.c\"\nint main(void) {\n char *value = \n# 5 \"null.c\" 3 4\n\t((void *)0)\n...\n}\n```\n\nThe result is the same.\n\nBecause <mark>NULL</mark> is not defined in <cd>stdio.h</cd>, it just includes <cd>stddef.h</cd>.\nIf <mark>NULL</mark> had been defined in <cd>stdio.h</cd>, it would have been re-defined by <cd>stddef.h</cd>.\n\n```c\n: `stddef.h` is also included by `stdio.h`\n# 1 \"null.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 31 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 32 \"<command-line>\" 2\n# 1 \"null.c\"\n\n# 1 \"/usr/include/stdio.h\" 1 3 4\n...\n# 1 \"/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h\" 1 3 4\n...\n```\n\n```c\n: content of stdio.h\n#define __need_size_t\n#define __need_NULL\n#include <stddef.h>\n...\n```\n\nLooking at gcc's <cd>stddef.h</cd>, <mark>NULL</mark> is defined as follows.\n\n```c\n: NULL definition in `stddef.h`\n/* A null pointer constant.  */\n\n#if defined (_STDDEF_H) || defined (__need_NULL)\n#undef NULL\t\t/* in case <stdio.h> has defined it. */\n#ifdef __GNUG__\n#define NULL __null\n#else   /* G++ */\n#ifndef __cplusplus\n#define NULL ((void *)0)\n#else   /* C++ */\n#define NULL 0\n#endif  /* C++ */\n#endif  /* G++ */\n#endif\t/* NULL not defined and <stddef.h> or need NULL.  */\n#undef\t__need_NULL\n```\n\nIn the ->[^1] GNU C++ compiler[/^], <mark>NULL</mark> is defined as <cd>__null</cd>, and in ->[^2] C++[/^], it is defined as <cd>0</cd>.\n\n```bash\n: build with GNU C++\n$ g++ -E null.c\n```\n\n```c\n: result with GNU C++\n# 4 \"null.c\"\nint main(void) {\n char *value = \n# 5 \"null.c\" 3 4\n\t__null\n...\n```\n\nIf so, does using `NULL` instead of 0 or 0 instead of `NULL` cause problems?\n\nThe most important difference between 0 and NULL is that `0` is <mark>int</mark> and `NULL` is <mark>void *</mark>.\n\nIn other words, on a 64-bit machine, the size of 0 and NULL will be different.\n\n```c\n: sizeof NULL in 64-bit\n#include <stdio.h>\n\nint main(void) {\n\tprintf(\"sizeof(0): %lu, sizeof(NULL): %lu\\n\", sizeof(0), sizeof(NULL));\n\n\treturn 0;\n}\n```\n```c\n: size of result\nsizeof(0): 4, sizeof(NULL): 8\n```\n\nSo, putting 0 where you expect <mark>NULL</mark> can cause problems because the sizes are different.\n\nThis problem is easily seen where you use variable-length argument like,\n> va_arg (val, *)\n\n```c\n: problem examples when put 0 not NULL\n#include <stdio.h>\n#include <stdarg.h>\n\nint expect(const char *fmt, ...) {\n\tva_list ap;\n\tchar *val;\n\n\tva_start(ap, fmt);\n\n\twhile (val = va_arg(ap, char *))\n\t\tprintf(\"value: %s\\n\", val);\n\n\tva_end(ap);\n\n\treturn 0;\n}\n\nint main(void) {\n  /* because of x86-64bit calling convention,\n        passed many arguments for reproduction. */\n\texpect(\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"fff\", \"ggg\", \"hhh\", \"iii\", 0);\n\n\treturn 0;\n}\n```\n\n\nexpect() function expects a `char*` pointer as `va argument`.\nSo it will pop an 8-byte from the stack, and if you put a `0` instead of <mark>NULL</mark>, you'll get a 4-byte stack overflow.\n\n```bash\n: compile with gcc-4\n$ gcc-4.8 -o null null.c\n```\n```bash\n: result\nvalue: bbb\nvalue: ccc\nvalue: ddd\nvalue: fff\nvalue: ggg\nvalue: hhh\nvalue: iii\nSegmentation fault (core dumped)\n```\n```c\n: change to\n//expect(\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"fff\", \"ggg\", \"hhh\", \"iii\", 0);\nexpect(\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"fff\", \"ggg\", \"hhh\", \"iii\", NULL);\n```\n```bash\n: result\nvalue: bbb\nvalue: ccc\nvalue: ddd\nvalue: fff\nvalue: ggg\nvalue: hhh\nvalue: iii\n```\nFor reference, the above code will not reproduce the problem in gcc-7 or higher.\nLooking at the code of gcc-7, when passing an argument, it is compiled to use `pushq` instead of `push`.\ngcc is getting smarter.\n\n```x86asm\n...\n7d9:\t6a 00                \tpushq  $0x0\n7db:\t48 8d 05 f5 00 00 00 \tlea    0xf5(%rip),%rax        # 8d7 \n...\n```\n\nIf you look at the man pages of execl-like functions, it is emphasized to use <mark>NULL</mark> instead of 0.\n\n> #### man execl\n> The const char *arg and subsequent ellipses in the execl(), execlp(), and execle() functions can be thought of as arg0, arg1, ..., argn.<br>\n> Together they describe a list of one or more pointers to <b>null-terminated</b> strings that represent the argument list available to the executed program.<br>\n> The first argument, by convention, should point to the filename associated with the file being executed.\n> The list of arguments must be terminated by a <mark>null pointer</mark>, and, since these are variadic functions, this pointer must be <mark>cast (char *) NULL</mark>.\n\nTake a look at the code in glibc's execl to see why.\nThe execl function uses <mark>NULL</mark> to know the number of argc.\n\n```c\n: glibc/posix/execl.c\n/* Execute PATH with all arguments after PATH until\n   a NULL pointer and environment from `environ'.  */\nint\nexecl (const char *path, const char *arg, ...)\n{\n  ptrdiff_t argc;\n  va_list ap;\n  va_start (ap, arg);\n  for (argc = 1; va_arg (ap, const char *); argc++)\n    {\n      if (argc == INT_MAX)\n\t{\n\t  va_end (ap);\n\t  errno = E2BIG;\n\t  return -1;\n\t}\n    }\n  va_end (ap);\n....\n```\nIn conclusion, you should always recognize that <mark>NULL != 0</mark> and avoid using them interchangeably.\n\n***\n<ol>\n\n[^1] GNU C++ = (__GNUG __=__ GNUC__&&__cplusplus)\n\n[^2] C++ = (__cplusplus)\n\n</ol>"
}