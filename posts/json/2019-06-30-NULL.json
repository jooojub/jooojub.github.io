{
 "content": "\n\nEnvironmets:\n * compiler: x86_64-linux-gnu 7.4.0, x86_64-linux-gnu 4.8.5\n * assembly: AT&T\n * code base: glibc 2.23.90\n\nAll content is written based on GNU C.\n\nGNU C에서 NULL과 0은 같지 않다는 것은 알고 있을 것입니다.\n> NULL != 0\n\n그래서 `NULL`이 뭔가요? 간단한 sample code로 쉽게 확인해 봅시다.\n\n### Check with sample code\n#### -> sample source code: null.c\n~~~c\n#include <stddef.h>\n\nint main(void) {\n\tchar *value = NULL;\n\n\treturn 0;\n}\n~~~\n#### -> preprocess only\n{% highlight bash %}\n$ gcc -E null.c\n{% endhighlight %}\n#### -> result\n{% highlight c %}\n# 1 \"null.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 31 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 32 \"<command-line>\" 2\n# 1 \"null.c\"\n# 1 \"/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h\" 1 3 4\n.....\n\n# 3 \"null.c\"\nint main(void) {\n char *value = \n# 4 \"null.c\" 3 4\n\t((void *)0) /* 0 == ((void *)0) */\n...\n}\n{% endhighlight %}\npre-process의 결과에서 볼 수 있듯이, `NULL` 은 ((void *)0) 로 replace 됩니다.\n> NULL == ((void *)0)\n\n`stddef.h` 대신 `stdio.h`를 include 하면 어떨까요?\n\n#### -> include `stdio.h` instead of `stddef.h`\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n\tchar *value = NULL;\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> preprocess only\n{% highlight bash %}\n$ gcc -E null.c\n{% endhighlight %}\n#### -> result\n{% highlight c %}\n# 4 \"null.c\"\nint main(void) {\n char *value = \n# 5 \"null.c\" 3 4\n\t((void *)0)\n...\n}\n{% endhighlight %}\n\n결과는 동일합니다.<br>\n왜냐하면 NULL은 `stdio.h`에 정의되어 있지 않고, 단지 `stddef.h`를 include 하고 있기 때문입니다.<br>\n만약 NULL이 `stdio.h`에 정의되어 있었다면, `stddef.h`에 의해 re-defined 되었을 겁니다.\n\n#### -> `stddef.h` is also included by `stdio.h`\n{% highlight c %}\n# 1 \"null.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 31 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 32 \"<command-line>\" 2\n# 1 \"null.c\"\n\n# 1 \"/usr/include/stdio.h\" 1 3 4\n...\n# 1 \"/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h\" 1 3 4\n...\n{% endhighlight %}\n#### -> content of stdio.h\n{% highlight c %}\n#define __need_size_t\n#define __need_NULL\n#include <stddef.h>\n...\n{% endhighlight %}\ngcc의 `stddef.h`를 살펴보면, `NULL`은 다음과 같이 정의되어 있습니다.\n\n#### -> NULL definition in `stddef.h`\n{% highlight c %}\n/* A null pointer constant.  */\n\n#if defined (_STDDEF_H) || defined (__need_NULL)\n#undef NULL\t\t/* in case <stdio.h> has defined it. */\n#ifdef __GNUG__\n#define NULL __null\n#else   /* G++ */\n#ifndef __cplusplus\n#define NULL ((void *)0)\n#else   /* C++ */\n#define NULL 0\n#endif  /* C++ */\n#endif  /* G++ */\n#endif\t/* NULL not defined and <stddef.h> or need NULL.  */\n#undef\t__need_NULL\n{% endhighlight %}\n\nGNU C++ compiler[^1]에서의 NULL은 `__null`로 정의되어 있으며, C++[^2]에서는 0으로 정의되어 있습니다.\n\n[^1]: GNU C++ = (__GNUG __=__ GNUC__&&__cplusplus)\n\n[^2]: C++ = (__cplusplus)\n#### -> check with GNU C++\n{% highlight bash %}\n$ g++ -E null.c\n{% endhighlight %}\n#### -> result with GNU C++<\n{% highlight c %}\n# 4 \"null.c\"\nint main(void) {\n char *value = \n# 5 \"null.c\" 3 4\n\t__null\n...\n{% endhighlight %}\n그렇다면,<br>\n0 대신 NULL을 사용하거나, NULL 대신 0을 사용하면 문제가 발생할까요?<br>\n0과 NULL의 가장 중요한 차이점은 0은 `int` 이며 NULL은 `void *` 라는 점입니다.<br>\n다시 말해, 64-bit machine에서는 0과 NULL의 사이즈가 다를 겁니다.\n\n#### -> sizeof NULL in 64-bit\n{% highlight c %}\n#include <stdio.h>\n\nint main(void) {\n\tprintf(\"sizeof(0): %lu, sizeof(NULL): %lu\\n\", sizeof(0), sizeof(NULL));\n\n\treturn 0;\n}\n{% endhighlight %}\n#### -> size of result\n{% highlight c %}\nsizeof(0): 4, sizeof(NULL): 8\n{% endhighlight %}\n그러므로, NULL을 기대하는 곳에 0을 넣으면 사이즈가 다르기 때문에 문제가 발생할 수 있습니다.<br>\n이러한 문제는 Variable-length Argument(e.g. va_arg (val, *)....)를 사용하는 곳에서 쉽게 드러납니다.\n\n#### -> problem examples when put 0 not NULL\n{% highlight c %}\n#include <stdio.h>\n#include <stdarg.h>\n\nint expect(const char *fmt, ...) {\n\tva_list ap;\n\tchar *val;\n\n\tva_start(ap, fmt);\n\n\twhile (val = va_arg(ap, char *))\n\t\tprintf(\"value: %s\\n\", val);\n\n\tva_end(ap);\n\n\treturn 0;\n}\n\nint main(void) {\n  /* because of x86-64bit calling convention,\n        passed many arguments for reproduction. */\n\texpect(\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"fff\", \"ggg\", \"hhh\", \"iii\", 0);\n\n\treturn 0;\n}\n{% endhighlight %}\n\nexpect() 함수는 va argument로 char* pointer를 기대하고 있습니다.<br>\n그래서 8-byte를 stack에서 pop 할 것이고, 만약 `NULL`대신 0을 넣었다면, 4-byte stack overflow가 발생할 것입니다.\n\n#### -> compile with gcc-4\n{% highlight bash %}\n$ gcc-4.8 -o null null.c\n{% endhighlight %}\n#### -> result\n<div class=\"noline\" markdown=\"1\">\n{% highlight bash %}\nvalue: bbb\nvalue: ccc\nvalue: ddd\nvalue: fff\nvalue: ggg\nvalue: hhh\nvalue: iii\nSegmentation fault (core dumped)\n{% endhighlight %}\n</div>\n#### -> change to\n{% highlight c %}\n//expect(\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"fff\", \"ggg\", \"hhh\", \"iii\", 0);\nexpect(\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"fff\", \"ggg\", \"hhh\", \"iii\", NULL);\n{% endhighlight %}\n#### -> result\n<div class=\"noline\" markdown=\"1\">\n{% highlight bash %}\nvalue: bbb\nvalue: ccc\nvalue: ddd\nvalue: fff\nvalue: ggg\nvalue: hhh\nvalue: iii\n{% endhighlight %}\n</div>\n\n참고로, gcc-7 이상에서는 위 코드로 문제가 재현 안될 것입니다.<br>\ngcc-7의 코드를 살펴보면, argument를 넘길 때, `push` 대신 `pushq`를 사용하도록 compile이 됩니다.<br>\ngcc가 점점 똑똑해지네요.\n\n{% highlight x86asm %}\n...\n7d9:\t6a 00                \tpushq  $0x0\n7db:\t48 8d 05 f5 00 00 00 \tlea    0xf5(%rip),%rax        # 8d7 \n...\n{% endhighlight %}\n\nexecl 류의 함수들의 man page를 살펴보면, 0 대신 NULL을 사용하라고 강조합니다.\n\n***\n<table>\n    <thead>\n        <tr>\n            <th>man execl</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n\t\t\t\t\t\t\t\tThe const char *arg and subsequent ellipses in the execl(), execlp(), and execle() functions can be thought of as arg0, arg1, ..., argn.<br><br>\n\t\t\t\t\t\t\t\tTogether they describe a list of one or more pointers to null-terminated strings that represent the argument list available to the executed program.<br><br>\n\t\t\t\t\t\t\t\tThe first argument, by convention, should point to the filename associated with the file being executed.<br>\n\t\t\t\t\t\t\t\tThe list of arguments must be terminated by a `null pointer`, and, since these are variadic functions, this pointer must be `cast (char *) NULL`.\n            </td>\n        </tr>\n    </tbody>\n</table>\n***\n\nglibc의 execl의 코드를 살펴보면 이유를 알 수 있습니다.<br>\nexecl 함수는 argc의 갯수를 알기 위해 NULL을 사용합니다.\n\n#### -> glibc/posix/execl.c\n{% highlight c %}\n/* Execute PATH with all arguments after PATH until\n   a NULL pointer and environment from `environ'.  */\nint\nexecl (const char *path, const char *arg, ...)\n{\n  ptrdiff_t argc;\n  va_list ap;\n  va_start (ap, arg);\n  for (argc = 1; va_arg (ap, const char *); argc++)\n    {\n      if (argc == INT_MAX)\n\t{\n\t  va_end (ap);\n\t  errno = E2BIG;\n\t  return -1;\n\t}\n    }\n  va_end (ap);\n....\n{% endhighlight %}\n\n결론적으로, `NULL != 0` 이라는 것을 항상 인지하고 서로 혼용해서 사용하는 것은 피해야 할 것 같네요.\n\n<div align=\"right\">\njooojub.\n</div>\n***\n"
}